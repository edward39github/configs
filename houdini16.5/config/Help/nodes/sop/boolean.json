{"body": [{"indent": 0, "text": ["Boolean"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["Combines two polygonal objects with boolean operators, or finds the intersection lines between two polygonal objects."]}, {"body": [{"indent": 0, "type": "para", "text": ["This node can perform several different functions according to the ", {"text": ["Operation"], "type": "ui"}, " parameter."]}, {"indent": 0, "type": "para", "text": ["The common operations are:"]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_subtract.jpg", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_subtract.jpg"}]}], "indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Boolean"], "type": "strong"}, " operations (union, intersect, subtract) between two \"solid\" models:"]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_shatter1.jpg", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_shatter1.jpg"}]}], "indent": 4, "role": "item", "type": "col"}, {"body": [{"indent": 8, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_shatter2.jpg", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_shatter2.jpg"}]}], "indent": 4, "role": "item", "type": "col"}], "container": true, "role": "item_group", "type": "col_group"}, {"indent": 4, "type": "para", "text": ["You can shatter with any number of complex cutting surfaces, allowing natural-looking, artistically controlled destruction."]}], "indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Shattering"], "type": "strong"}, " a solid model using cutting surfaces:"]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["Generating polylines along the ", {"text": ["seams"], "type": "strong"}, " where two models intersect."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Detecting"], "type": "strong"}, " intersections and putting intersecting polygons into groups."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "text": ["You can specify the input models as \"solid\" (treat the model surface as if it encloses a solid filled space) or \"surface\" (treat the model surfaces like flat planes)."]}, {"body": [{"body": [], "indent": 0, "text": [" Boolean shattering"], "role": "item", "attrs": {"id": "204607962"}, "type": "vimeo"}], "container": true, "role": "item_group", "type": "vimeo_group"}], "indent": 0, "level": 2, "text": ["Overview"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["In the images below, the \"shatter\" examples use an ", {"text": ["Exploded View node"], "fullpath": "/nodes/sop/explodedview", "scheme": "Node", "type": "link", "value": "/nodes/sop/explodedview"}, " to make the separate pieces clear."]}, {"body": [{"body": [{"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Before "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["To illustrate boolean operations between solids, we\u2019ll use two simple offset boxes."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsol_before.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsol_before.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Union "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Creates a new solid which encloses the combined volume of the two inputs."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsol_union.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsol_union.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Intersect "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Creates a new solid which encloses any shared volume(s) between the two inputs."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsol_intersect.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsol_intersect.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Subtract "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Removes the shared volume(s) from one or both inputs."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsol_subtract.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsol_subtract.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Shatter "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Like a combination of Intersect and Subtract: cuts along the intersections between the surfaces of the solids to carve out new shapes."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsol_shatter.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsol_shatter.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Seam "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Outputs polyline(s) where the surfaces of the two solids intersect."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsol_seam.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsol_seam.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}], "type": "table", "thead": []}], "indent": 0, "level": 3, "text": ["Solid/Solid boolean operations"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Before "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["To illustrate boolean operations between a solid and a surface, we\u2019ll use a simple box and a corner."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsurf_before.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsurf_before.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Union "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Combines the solid with ", {"text": ["double walls"], "type": "em"}, " around parts of the surface outside the solid\u2019s volume."]}, {"indent": 8, "type": "para", "text": ["Note that the open surfaces become double-walled, or what you might think of as \"solids with zero volume\" and overlapping points. In the image on the right, the parts of the \"corner\" outside the cube are now double-walled with double points at each corner (see the schematic views below)."]}, {"indent": 8, "type": "para", "text": ["This is a logically consistent outcome given how the node sees the interaction between solids and surfaces, but it can be surprising if you don\u2019t expect it. You might be able to use this geometry for what you want, but in general this operation is not very useful."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsurf_union.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsurf_union.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Intersect "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Trims away any parts of the surface that are exterior to the solid."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsurf_intersect.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsurf_intersect.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Subtract "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Subtracting a surface from a solid creates ", {"text": ["double-walled"], "type": "em"}, " cuts in the solid where it intersects the surface."]}, {"indent": 8, "type": "para", "text": ["If the surface goes \"all the way through\" the solid, this is like shattering, where the surface cuts the solid into disconnected pieces. However, if (as on the right) the surface doesn\u2019t fully intersect the solid, it \"cuts out\" a zero-width shape from the solid, leaving double walls with double points at the corners (see the schematic views below)."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsurf_subtract_aminusb.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsurf_subtract_aminusb.png"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Subtracting a solid from a surface trims any parts of the surface that are inside the solid."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsurf_subtract_bminusa.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsurf_subtract_bminusa.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Shatter "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Like a combination of Intersect and Subtract: carves out the intersections into new shapes."]}, {"indent": 8, "type": "para", "text": ["If the surface goes \"all the way through\" the solid, the surface cuts the solid into disconnected pieces. However, if the surface doesn\u2019t fully intersect the solid, it \"cuts out\" a zero-width shape from the solid, leaving double walls with double points at the corners (see the schematic views below)."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsurf_shatter.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsurf_shatter.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Seam "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Outputs polyline(s) where the surface intersects the solid."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_solsurf_seam.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_solsurf_seam.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}], "type": "table", "thead": []}], "indent": 0, "level": 3, "text": ["Solid/Surface boolean operations"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Before "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["To illustrate boolean operations between surfaces, we\u2019ll use two corner shape. The two shapes have an overlapping surface (in the top right) as well as an intersection (bottom)."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_surfsurf_before.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_surfsurf_before.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Union "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Combines coincident surfaces, and combines intersecting parts of the two surfaces."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_surfsurf_union.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_surfsurf_union.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Intersect "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Only retains coincident surfaces."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_surfsurf_intersect.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_surfsurf_intersect.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Subtract "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Removes coincident surfaces, and creates double-sided cuts along intersections."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_surfsurf_subtract_aminusb.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_surfsurf_subtract_aminusb.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Shatter "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Like a combination of Intersect and Subtract: carves out intersections, and retains coincident surfaces as new shapes."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_surfsurf_shatter.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_surfsurf_shatter.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "td", "type": "cell", "text": ["Seam "]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Outputs polygons for coincident surfaces, and polylines where the surfaces intersect."]}], "indent": 4, "role": "item", "type": "fig", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_surfsurf_seam.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_surfsurf_seam.png"}]}], "container": true, "role": "item_group", "type": "fig_group"}], "role": "td", "type": "cell"}], "type": "row"}], "type": "table", "thead": []}], "indent": 0, "level": 3, "text": ["Surface/Surface boolean operations"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["This table shows more schematic illustrations of the various operations, which attempts to clarify some aspects of the various outputs that are invisible in the viewport. Double-walls are represented as having thickness, and multiply-connected points are represented as dots."]}, {"body": [{"body": [{"indent": 0, "role": "th", "type": "cell", "text": ["Union "]}, {"indent": 4, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_ss_union.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_ss_union.png"}, " "]}, {"indent": 8, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_oo_union.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_oo_union.png"}, " "]}, {"body": [{"indent": 12, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_so_union.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_so_union.png"}]}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "th", "type": "cell", "text": ["Intersect "]}, {"indent": 4, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_ss_intersect.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_ss_intersect.png"}, " "]}, {"indent": 8, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_oo_intersect.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_oo_intersect.png"}, " "]}, {"body": [{"indent": 12, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_so_intersect.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_so_intersect.png"}]}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "th", "type": "cell", "text": ["A - B "]}, {"indent": 4, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_ss_aminusb.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_ss_aminusb.png"}, " "]}, {"indent": 8, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_oo_aminusb.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_oo_aminusb.png"}, " "]}, {"body": [{"indent": 12, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_so_aminusb.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_so_aminusb.png"}]}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "th", "type": "cell", "text": ["B - A "]}, {"indent": 4, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_ss_bminusa.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_ss_bminusa.png"}, " "]}, {"indent": 8, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_oo_bminusa.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_oo_bminusa.png"}, " "]}, {"body": [{"indent": 12, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_so_bminusa.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_so_bminusa.png"}]}], "role": "td", "type": "cell"}], "type": "row"}, {"body": [{"indent": 0, "role": "th", "type": "cell", "text": ["Shatter "]}, {"indent": 4, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_ss_shatter.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_ss_shatter.png"}, " "]}, {"indent": 8, "role": "td", "type": "cell", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_oo_shatter.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_oo_shatter.png"}, " "]}, {"body": [{"indent": 12, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_so_shatter.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_so_shatter.png"}]}], "role": "td", "type": "cell"}], "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "role": "th", "type": "cell"}, {"indent": 4, "role": "th", "type": "cell", "text": ["Solid/Solid "]}, {"indent": 8, "role": "th", "type": "cell", "text": ["Surface/Surface "]}, {"indent": 12, "role": "th", "type": "cell", "text": ["Solid/Surface "]}], "type": "row"}]}], "indent": 0, "level": 3, "text": ["Schematic views"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Boolean operations"], "container": true, "type": "h", "id": "ops"}, {"body": [{"indent": 0, "type": "para", "text": ["For solid models with \"overlapping\" or \"concentric\" surfaces (for example, boxes within boxes, or geometry with self-intersections), you can use the \"Custom\" operation to extract only the solid area at a certain \"depth\" (with respect to either or both inputs)."]}, {"indent": 0, "type": "para", "text": ["The \"depth\" of any point inside the solid is measured as the minimum number of surfaces you'd have to cross to get outside the model."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["In this illustration, a model with three concentric boxes (gray) is combined with a single-level box (green). The numbers in the illustration show the \"depth\" of each volume. So, if you set the custom range to ", {"text": ["4-9999"], "type": "code"}, ", the output would only contain the dark-gray square in the center."]}], "indent": 0, "role": "item", "type": "fig", "text": [" ", {"text": "", "fullpath": "/images/nodes/sop/boolean_depth.svg", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_depth.svg"}]}, {"body": [{"indent": 4, "type": "para", "text": ["In this illustration, a single model has a two self-intersections, creating a nested space inside. Setting the custom range to ", {"text": ["2-9999"], "type": "code"}, " would delete the light grey parts and leave the dark grey box. The Custom operation can be useful for removing the \"outer layers\" to get at these kinds of spaces inside."]}], "indent": 0, "text": [" ", {"text": "", "fullpath": "/images/nodes/sop/boolean_custom2.svg", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_custom2.svg"}], "role": "item", "attrs": {"display": "left"}, "type": "fig"}], "container": true, "role": "item_group", "type": "fig_group"}], "indent": 0, "level": 2, "text": ["Custom"], "container": true, "type": "h", "id": "custom"}, {"body": [{"indent": 0, "type": "para", "text": ["This mode passes through the first input geometry, but adds optional ", {"text": ["groups"], "fullpath": "/model/groups", "scheme": null, "type": "link", "value": "/model/groups"}, " and/or ", {"text": ["attributes"], "fullpath": "/model/attributes", "scheme": null, "type": "link", "value": "/model/attributes"}, " containing the intersecting polygons. This lets you create effects using the intersecting polygons."]}], "indent": 0, "level": 2, "text": ["Detect"], "container": true, "type": "h", "id": "detect"}, {"body": [{"indent": 0, "type": "para", "text": ["This mode is used for internal testing and is probably not generally useful, except possibly as a quick tetrahedralize. It outputs the raw triangulated mesh from an intermediate step in the node\u2019s algorithm, equivalent to the union of all polygons as surfaces. The polygons may have inconsistent orientations."]}], "indent": 0, "level": 2, "text": ["Resolve"], "container": true, "type": "h", "id": "resolve"}, {"body": [{"body": [{"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": ["In general solids should be closed and airtight (but see below)."]}, {"body": [{"indent": 8, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_orig_ghost.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_orig_ghost.png"}]}], "indent": 4, "blevel": 6, "type": "bullet", "text": ["Solids should have ", {"text": ["all normals pointing outward"], "type": "em"}, " (consistent polygon winding directions). You can turn on display of normals in the viewport to check for inverted or double-layered polygons."]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": ["Solids should not have ", {"text": ["non-manifold"], "type": "em"}, " edges (that is, they should have no edges shared by more than two polygons, like a T junction)."]}], "container": true, "type": "bullet_group"}, {"indent": 4, "type": "para", "text": ["If the node encounters non-manifold edges or inconsistent normals, it ", {"text": ["will"], "type": "em"}, " do ", {"text": ["something"], "type": "em"}, " with the geometry, but it might not be what you wanted (the problems can give the algorithm the wrong idea of what\u2019s \"inside\" and \"outside\"). In these cases the node will show a warning explaining what created the ambiguity. You can read the warning in the ", {"fragment": "#info", "text": ["node info window"], "value": "/network/nodes#info", "fullpath": "/network/nodes#info", "scheme": null, "type": "link"}, ". The warning includes a group spec specifying the problem polygons."]}], "indent": 0, "blevel": 2, "type": "bullet", "text": ["In the parameters you specify whether an input is a \"solid\" or \"surface\" (zero-width). If you specify that an input is \"solid\", you need to make sure it\u2019s a ", {"text": ["good"], "type": "em"}, " solid."]}, {"body": [{"indent": 4, "type": "para", "text": ["If you try to use an open surface as a solid and it creates inconsistencies, the node will highlight the problem boundary edges in red."]}], "indent": 0, "blevel": 2, "type": "bullet", "text": ["It is possible to use open surfaces as solids as long as this does not create logical contradictions. For example, no unshared edge of a mesh treated as solid can cross the interior of that or any other solid."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["You can turn off visualization guides when the node is active. Right-click in the viewport or click the Boolean icon on the left side of the operation toolbar (at the top of the viewer), and turn off visualization options in the menu."]}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": ["Use the ", {"fragment": "#groups", "text": ["group list"], "value": "/basics/select#groups", "fullpath": "/basics/select#groups", "scheme": null, "type": "link"}, " with the Select tool in the viewport to highlight disconnected parts as you move the mouse over them. This doesn\u2019t require modifying the network."]}, {"body": [{"indent": 8, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_color_pieces.png", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_color_pieces.png"}]}], "indent": 4, "blevel": 6, "type": "bullet", "text": ["Use an ", {"text": ["Assemble node"], "fullpath": "/nodes/sop/assemble", "scheme": "Node", "type": "link", "value": "/nodes/sop/assemble"}, " to give the polygons of each disconnected piece a common ", {"text": ["name"], "type": "code"}, " attribute value, then use a ", {"text": ["Color node"], "fullpath": "/nodes/sop/color", "scheme": "Node", "type": "link", "value": "/nodes/sop/color"}, " or ", {"text": ["color visualizer"], "fullpath": "/visualizers/color", "scheme": null, "type": "link", "value": "/visualizers/color"}, " with the \"Random color by attribute\" option to color the polygons based on the ", {"text": ["name"], "type": "code"}, " value:"]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": ["Use an ", {"text": ["Exploded View node"], "fullpath": "/nodes/sop/explodedview", "scheme": "Node", "type": "link", "value": "/nodes/sop/explodedview"}, " to move the parts away from each other."]}], "container": true, "type": "bullet_group"}], "indent": 0, "blevel": 2, "type": "bullet", "text": ["There are different ways to visualize connectivity after the boolean operation:"]}, {"body": [{"indent": 4, "type": "para", "text": ["If you connect only one input and leave Set A and Set B groups blank, the boolean operation applies to the model ", {"text": ["with itself"], "type": "em"}, ". You can use this with Shatter to separate the model along its self-intersections. The other boolean operations are logically consistent (union and intersect pass everything through, subtract deletes everything) but not very useful."]}], "indent": 0, "blevel": 2, "type": "bullet", "text": ["You can connect two polygonal geometries to the node\u2019s two inputs, or connect one input and operate on different groups using the Set A ", {"text": ["Group"], "type": "ui"}, " and Set B ", {"text": ["Group"], "type": "ui"}, " parameters."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["This node ", {"text": ["interpolates"], "type": "em"}, " point/vertex attributes and ", {"text": ["copies"], "type": "em"}, " primitive attributes."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["It\u2019s usually not worth trying to align edges on the two models for aesthetic purposes. For example, trying to put a cutting plane ", {"text": ["exactly"], "type": "em"}, " on the equator of a sphere. Due to tiny numeric precision errors, the two edges can look lined up even zoomed in but technically have a gap between them according to the computer. Boolean will ", {"fragment": "#collapsetinyedges", "text": ["automatically clean up"], "value": "#collapsetinyedges", "fullpath": "/nodes/sop/boolean#collapsetinyedges", "scheme": null, "type": "link"}, " tiny polygons created by this kind of mis-alignment."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["Red dots in the node\u2019s visualization show problem areas, such as microscopically tiny polygons in the output."]}, {"body": [{"indent": 4, "type": "para", "text": ["You can try turning off ", {"text": ["Assume seam polygons are flat"], "type": "ui"}, " on the upstream Boolean node. If that doesn\u2019t work, set ", {"text": ["Detriangulate"], "type": "ui"}, " to \"Only unchanged polygons\". These settings leave more triangles in the output but might fix the self-intersection."]}], "indent": 0, "blevel": 2, "type": "bullet", "text": ["If you're doing highly complicated procedural booleans, for example with extremely fine details/differences between surfaces (as opposed to using booleans for visual modeling), it\u2019s possible to get unintended results if you follow a boolean with another boolean, because ", {"text": ["precision issues"], "fullpath": "/nodes/sop/1", "scheme": "Fold", "type": "link", "value": "1"}, " can cause microscopic self-intersections in Boolean\u2019s output."]}], "container": true, "type": "bullet_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Because of floating point precision issues, non-triangular polygons are almost always technically non-planar (unless they lie on an axis), so this node first triangulates the input geometry so it can reason with perfectly-flat polygons. Then at the end it \"de-triangulates\" the polygons it divided (unless you set ", {"text": ["Detriangulate"], "type": "ui"}, " to \"No polygons\")."]}, {"indent": 4, "type": "para", "text": ["This triangulation introduces a crease in the middle of what is for practical purposes a \"flat\" polygon, and even after de-triangulating the output, the polygon will an extra point where the crease was. This can be annoying to work with. So when ", {"text": ["Assume seam polygons are flat"], "type": "ui"}, " is on, the node removes the extra point as well."]}, {"indent": 4, "type": "para", "text": ["The issue is that Boolean works internally at arbitrary precision, when it generates output it has to \"snap\" the points of the arbitrary precision geometry to the lower precision of hardware floating-point numbers. This might cause points that were separate at arbitrary precision to overlap at floating-point precision, creating incredibly tiny self-intersections. This is especially true when the node removes points on \"practically flat\" polygons because ", {"text": ["Assume seam polygons are flat"], "type": "ui"}, " is on."]}], "indent": 0, "text": [" Precision issues"], "role": "item", "attrs": {"fold": "1"}, "type": "box"}], "container": true, "role": "item_group", "type": "box_group"}], "indent": 0, "level": 2, "text": ["Tips and notes"], "container": true, "type": "h", "id": "tips"}, {"body": [{"indent": 0, "text": [" Set A "], "type": "sep", "level": 3}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Use a subset of the first input as the \"A\" object."]}], "indent": 0, "text": ["Group"], "role": "item", "attrs": {"id": "agroup"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Whether to treat this geometry like the boundary of a solid object, or as a flat surface with no interior or exterior."]}], "indent": 0, "text": ["Treat As"], "role": "item", "attrs": {"id": "asurface"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Automatically fix the model if it has any crossing or overlapping surfaces. Some operations require non-intersecting geometry and so will ignore this setting and always resolve."]}], "indent": 0, "text": ["Remove self-intersections"], "role": "item", "attrs": {"id": "resolvea"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "text": [" Set B "], "type": "sep", "level": 3}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Use a subset of the second input as the \"B\" object. If only one input is connected, this refers to a group from the first input instead. This lets you operate on two groups from the same geometry."]}], "indent": 0, "text": ["Group"], "role": "item", "attrs": {"id": "bgroup"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Whether to treat this geometry like the boundary of a solid object, or as a flat surface with no interior or exterior."]}], "indent": 0, "text": ["Treat As"], "role": "item", "attrs": {"id": "bsurface"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Automatically fix the model if it has any crossing or overlapping surfaces. Some operations require non-intersecting geometry and so will ignore this setting and always resolve."]}], "indent": 0, "text": ["Remove self-intersections"], "role": "item", "attrs": {"id": "resolveb"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "text": [" Output geometry "], "type": "sep", "level": 3}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["How to combine/modify the inputs. See ", {"fragment": "#ops", "text": ["Operations"], "value": "#ops", "fullpath": "/nodes/sop/boolean#ops", "scheme": null, "type": "link"}, " above."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Operation"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "type": "para", "text": ["The following parameters appear when ", {"text": ["Operation"], "type": "ui"}, " is a boolean operation (Union, Intersect, Subtract, or Shatter)."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Internally, this node converts the input geometry to triangles. This controls whether to convert the triangulated geometry back to N-gons matching the originals for output."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Merge neighbouring triangles originating from the same input polygon back together."]}], "indent": 4, "type": "dt", "text": ["All Polygons"]}, {"body": [{"indent": 8, "type": "para", "text": ["If an input polygon is cut as part of the operation, keep it as triangles. Otherwise put triangulated polygons back together."]}], "indent": 4, "type": "dt", "text": ["Only Unchanged Polygons"]}, {"body": [{"indent": 8, "type": "para", "text": ["Output the triangulated geometry."]}], "indent": 4, "type": "dt", "text": ["No polygons"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Detriangulate"], "role": "item", "attrs": {"id": "detriangulate"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Most \"flat\" polygons are not technically flat because of floating-point precision issues. This ignores those kinds of differences when de-triangulating the output. The default (on) is fine in almost all cases, but you may want to turn this off if you are doing procedural booleans on geometry with extremely fine detail/separation between surfaces. Turning this off will result in more triangles in the output."]}, {"indent": 4, "type": "para", "text": ["See the ", {"fragment": "#tips", "text": ["tips and notes"], "value": "#tips", "fullpath": "/nodes/sop/boolean#tips", "scheme": null, "type": "link"}, " above for more information."]}], "indent": 0, "text": ["Assume seam polygons are flat"], "role": "item", "attrs": {"id": "removeinlinepoints"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Cut the output surface into separate polygons along the seams, with each polygon on either side of the seam having its own copy of each seam point. You can use this to prevent blending point attributes across seams in the output."]}], "indent": 0, "text": ["Unique Points Along Seams"], "role": "item", "attrs": {"id": "uniqueseams"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Even if you try very hard to align edges on the two models you are combining, tiny numeric precision errors can (and usually will) cause the edges to be microscopically mis-aligned, creating extra edges in the output. When this option is on, the node intelligently fuses these tiny edges away. You should not turn this off unless you really know that you want microscopically thin polygons for some reason."]}, {"indent": 4, "type": "para", "text": [{"text": "", "fullpath": "/images/nodes/sop/boolean_tinyedges.svg", "scheme": "Image", "type": "link", "value": "/images/nodes/sop/boolean_tinyedges.svg"}]}], "indent": 0, "text": ["Collapse tiny seam-adjacent edges"], "role": "item", "attrs": {"id": "collapsetinyedges"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["When ", {"text": ["Collapse tiny seam-adjacent edges"], "type": "ui"}, " is on, edges this length or smaller are automatically fused in the output."]}], "indent": 0, "text": ["Edge length threshold"], "role": "item", "attrs": {"id": "lengththreshold"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "type": "para", "text": ["The following parameters appear when ", {"text": ["Operation"], "type": "ui"}, " is \"Custom\"."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Range of depths in A for the generated result. For example you\n    can use range 1..1000 to cover the interior of A (1000 being\n    just a large upper bound), or use -1000..0 to cover the\n    exterior of A, or use 1..1 to cover the interior of A but\n    excluding any regions that is multiple levels deep. "]}], "indent": 0, "text": ["A Depth Min/Max"], "role": "item", "attrs": {"id": "adepth1"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Similar to A depth but measured relative to B. "]}], "indent": 0, "text": ["B Depth Min/Max"], "role": "item", "attrs": {"id": "bdepth1"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Specifies whether the range requirement for the generated pieces\n    must conform to the given range for A, B, both, or exactly one \n    of the two."]}], "indent": 0, "text": ["Output Pieces Matching"], "role": "item", "attrs": {"id": "windingop"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["If toggled on, the generated solid pieces that share a wall, \n    across which, for example, the A depth changes by one within the\n    given range, are merged into a single solid result, as opposed to\n    being generated as separate solids. "]}], "indent": 0, "text": ["Merge Adjacent Pieces"], "role": "item", "attrs": {"id": "mergenbrs"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "type": "para", "text": ["The following parameters appear when ", {"text": ["Operation"], "type": "ui"}, " is \"Seam\"."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Output polylines representing the seams where A intersects itself."]}], "indent": 0, "text": ["Generate A-A seams"], "role": "item", "attrs": {"id": "generateaaseams"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Output polylines representing the seams where B intersects itself."]}], "indent": 0, "text": ["Generate B-B seams"], "role": "item", "attrs": {"id": "generatebbseams"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Output polylines representing the seams where A intersects B."]}], "indent": 0, "text": ["Generate A-B seams"], "role": "item", "attrs": {"id": "generateabseams"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "type": "para", "text": ["The following parameters appear when ", {"text": ["Operation"], "type": "ui"}, " is \"Detect\"."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Creates a group in the output containing polygons involved in self-intersections in A."]}], "indent": 0, "text": ["AxA Polygons"], "role": "item", "attrs": {"id": "axapolys"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Creates a group in the output containing polygons from A that intersect B."]}], "indent": 0, "text": ["AxB Polygons"], "role": "item", "attrs": {"id": "axbpolys"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Creates an ", {"text": ["attribute"], "type": "em"}, " on A polygons containing an array of primitive numbers from A that intersect the polygon."]}], "indent": 0, "text": ["AxA List"], "role": "item", "attrs": {"id": "axalist"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Creates an ", {"text": ["attribute"], "type": "em"}, " on A polygons containing an array of primitive numbers from B that intersect the polygon."]}], "indent": 0, "text": ["AxB List"], "role": "item", "attrs": {"id": "axblist"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "text": [" Output Primitive Groups "], "type": "sep", "level": 3}, {"indent": 0, "type": "para", "text": ["Turn on the checkbox next to a group to have the node create that group in the output geometry."]}, {"indent": 0, "type": "para", "text": ["The node only creates these groups for the boolean operations (Union, Intersect, Subtract, Shatter, and Custom)."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Create a group containing polygons from A that are enclosed by B."]}], "indent": 0, "text": ["A inside B"], "role": "item", "attrs": {"id": "ainsideb"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a group containing polygons from A that are exterior to B."]}], "indent": 0, "text": ["A outside B"], "role": "item", "attrs": {"id": "aoutsideb"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a group containing polygons from B that are enclosed by A."]}], "indent": 0, "text": ["B inside A"], "role": "item", "attrs": {"id": "binsidea"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a group containing polygons from B that are exterior to A."]}], "indent": 0, "text": ["B outside A"], "role": "item", "attrs": {"id": "boutsidea"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"indent": 0, "text": [" Output Edge Groups "], "type": "sep", "level": 3}, {"indent": 0, "type": "para", "text": ["Turn on the checkbox next to a group to have the node create that group in the output geometry."]}, {"indent": 0, "type": "para", "text": ["The node does not output edge groups when ", {"text": ["Operation"], "type": "ui"}, " is \"Detect\" or \"Resolve\"."]}, {"body": [{"body": [{"indent": 4, "type": "para", "text": ["Create a group containing edges representing the seams where A intersects itself."]}], "indent": 0, "text": ["A-A seams"], "role": "item", "attrs": {"id": "aaseamedges"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a group containing edges representing the seams where B intersects itself."]}], "indent": 0, "text": ["B-B seams"], "role": "item", "attrs": {"id": "bbseamedges"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a group containing edges representing the seams where A intersects B."]}], "indent": 0, "text": ["A-B seams"], "role": "item", "attrs": {"id": "abseamedges"}, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/sop/clip", "scheme": "Node", "type": "link", "value": "/nodes/sop/clip"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/sop/surfsect", "scheme": "Node", "type": "link", "value": "/nodes/sop/surfsect"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/sop/break", "scheme": "Node", "type": "link", "value": "/nodes/sop/break"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "container": true, "type": "related_section", "id": "related"}], "summary": ["Combines two polygonal objects with boolean operators, or finds the intersection lines between two polygonal objects."], "type": "root", "attrs": {"version": "2.0", "tags": "polygons, boolean, seams, merge, model", "namespace": null, "internal": "boolean", "context": "sop", "type": "node", "icon": "SOP/boolean"}, "title": ["Boolean"]}