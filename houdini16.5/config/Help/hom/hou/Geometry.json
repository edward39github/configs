{"body": [{"indent": 0, "text": [{"text": "hou.", "type": "supertitle"}, "Geometry"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["A Geometry object contains the points and primitives that define a 3D\ngeometric shape.  For example, each SOP node in Houdini generates a single\nGeometry object."]}, {"indent": 0, "type": "para", "text": ["If you ask a SOP for its geometry via ", {"fragment": "#geometry", "text": "", "value": "/hom/hou/SopNode#geometry", "fallback_text": "hou.SopNode.geometry", "fullpath": "/hom/hou/SopNode#geometry", "scheme": "Hom", "type": "link"}, ", you\u2019ll get\na read-only reference to it.  If the SOP recooks, the corresponding Geometry\nobject will update to the SOP\u2019s new geometry.  If the SOP is deleted, accessing\nthe Geometry object will raise a ", {"text": "", "value": "/hom/hou/ObjectWasDeleted", "fallback_text": "hou.ObjectWasDeleted", "fullpath": "/hom/hou/ObjectWasDeleted", "scheme": "Hom", "type": "link"}, " exception.  If\nyou call methods that try to modify the geometry, they will raise a\n", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " exception."]}, {"indent": 0, "type": "para", "text": ["If you do not want the geometry to update when the SOP recooks, you can call\n", {"fragment": "#freeze", "text": "", "value": "/hom/hou/Geometry#freeze", "fallback_text": "hou.Geometry.freeze", "fullpath": "/hom/hou/Geometry#freeze", "scheme": "Hom", "type": "link"}, ".  freeze returns another Geometry object that will\nnot change when the SOP recooks.  Accessing frozen Geometry is slightly faster,\nsince Houdini does not need to look up the SOP node for each access, so you\nmay want to use frozen geometry for speed-crucial operations."]}, {"indent": 0, "type": "para", "text": ["If you're writing a SOP using Python, you will have read-write access to\nthe geometry, and it will be frozen.  To create a Python-defined SOP,\nselect ", {"text": ["File \u25b8 New Operator Type\u2026"], "type": "ui"}, " and place the Python code in the\n", {"text": ["Code"], "type": "ui"}, " tab."]}, {"indent": 0, "type": "para", "text": ["Finally, you can allocate a new frozen geometry with read-write access by\ncreating an instance of ", {"text": "", "value": "/hom/hou/Geometry", "fallback_text": "hou.Geometry", "fullpath": "/hom/hou/Geometry", "scheme": "Hom", "type": "link"}, "."]}, {"body": [{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Look up a point attribute by name.  Returns the corresponding\n    ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object, or None if no attribute exists with that name."]}, {"indent": 4, "type": "para", "text": ["Note that the point position attribute is named ", {"text": ["P"], "type": "code"}, " and is 3 floats in\n    size.  Also, the point weight attribute is named ", {"text": ["Pw"], "type": "code"}, " and is 1 float in\n    size.  These attributes always exist in HOM, even though they are not\n    listed by Houdini\u2019s UI."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Point#attribValue", "fallback_text": "hou.Point.attribValue", "fullpath": "/hom/hou/Point#attribValue", "scheme": "Hom", "type": "link"}, " for an example."]}], "indent": 0, "text": [{"text": ["findPointAttrib(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findPointAttrib", "replaces": "/expressions/haspointattrib"}, "type": "methods_item", "id": "findPointAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Look up a primitive attribute by name.  Returns the corresponding\n    ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object, or None if no attribute exists with that name."]}], "indent": 0, "text": [{"text": ["findPrimAttrib(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findPrimAttrib", "replaces": "/expressions/hasprimattrib"}, "type": "methods_item", "id": "findPrimAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Look up a vertex attribute by name.  Returns the corresponding\n    ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object, or None if no attribute exists with that name."]}], "indent": 0, "text": [{"text": ["findVertexAttrib(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findVertexAttrib", "replaces": "/expressions/hasvertexattrib"}, "type": "methods_item", "id": "findVertexAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Look up a global (a.k.a. detail) attribute by name.  Returns the\n    corresponding ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object, or None if no attribute exists with\n    that name."]}], "indent": 0, "text": [{"text": ["findGlobalAttrib(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findGlobalAttrib", "replaces": "/expressions/hasdetailattrib"}, "type": "methods_item", "id": "findGlobalAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the point attributes."]}, {"indent": 4, "type": "para", "text": ["Note that the point position attribute is named ", {"text": ["P"], "type": "code"}, " and is 3 floats in\n    size.  Also, the point weight attribute is named ", {"text": ["Pw"], "type": "code"}, " and is 1 float in\n    size.  These attributes always exist in HOM, even though they are not\n    listed by Houdini\u2019s UI."]}], "indent": 0, "text": [{"text": ["pointAttribs(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointAttribs"}, "type": "methods_item", "id": "pointAttribs"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the primitive attributes."]}], "indent": 0, "text": [{"text": ["primAttribs(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primAttribs"}, "type": "methods_item", "id": "primAttribs"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the vertex attributes."]}], "indent": 0, "text": [{"text": ["vertexAttribs(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::vertexAttribs"}, "type": "methods_item", "id": "vertexAttribs"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the global (a.k.a. detail) attributes."]}], "indent": 0, "text": [{"text": ["globalAttribs(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::globalAttribs"}, "type": "methods_item", "id": "globalAttribs"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new point, primitive, vertex, or global (a.k.a. detail) attribute.\n    Returns a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object describing the newly created attribute.\n    You would typically call this method from the code of a Python-defined\n    SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/attribType", "fallback_text": "hou.attribType", "fullpath": "/hom/hou/attribType", "scheme": "Hom", "type": "link"}, " value to specify if the new attribute should be\n        a point, primitive, vertex, or global attribute."]}], "indent": 4, "type": "dt", "text": ["type"]}, {"body": [{"indent": 8, "type": "para", "text": ["The new attribute\u2019s name.  Each attribute in the geometry must have\n        a unique name."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["The default value for this attribute.  When an attribute is created,\n        all existing elements (e.g. primitives or points) will store this\n        value.  As well, elements that you add later will also use this value."]}, {"indent": 8, "type": "para", "text": ["This value also determines the attribute\u2019s data type, and may be one\n        of the following:"]}, {"body": [{"indent": 8, "blevel": 10, "type": "bullet", "text": ["an integer"]}, {"indent": 8, "blevel": 10, "type": "bullet", "text": ["a float"]}, {"indent": 8, "blevel": 10, "type": "bullet", "text": ["a string"]}, {"indent": 8, "blevel": 10, "type": "bullet", "text": ["an integer sequence"]}, {"indent": 8, "blevel": 10, "type": "bullet", "text": ["a float sequence"]}], "container": true, "type": "bullet_group"}, {"indent": 8, "type": "para", "text": ["If the default value is a sequence of integers or floats, the sequence\n        size will determine the attribute\u2019s size.  Otherwise, the attribute\u2019s\n        size is 1."]}, {"indent": 8, "type": "para", "text": ["String attributes do not support a default value and use this value\n        solely for type determination."]}], "indent": 4, "type": "dt", "text": ["default_value"]}, {"body": [{"indent": 8, "type": "para", "text": ["This parameter may only be set to ", {"text": ["True"], "type": "code"}, " when the default value is a\n        sequence of 3 floats.  For such attributes, Houdini will not modify the\n        attribute values when it transforms (translates, rotates, etc.) the\n        geometry.  If you want to the attribute to be transformed as a vector\n        (such as a normal vector) when Houdini transforms the geometry, set\n        this parameter to ", {"text": ["True"], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["transform_as_normal"]}, {"body": [{"indent": 8, "type": "para", "text": ["If ", {"text": ["True"], "type": "code"}, ", Houdini will create a local variable for this attribute\n        that may be used in parameter expressions.  The name of the local\n        variable is the attribute\u2019s name, all in upper case.  The mapping from\n        attribute names to local variables is stored in a special global\n        attribute named ", {"text": ["\"varmap\""], "type": "code"}, "."]}], "indent": 4, "type": "dt", "text": ["create_local_variable"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if an attribute with this name already\n    exists.  If you are familiar with the C++ Houdini Development Kit (HDK),\n    you know that Houdini can support attributes with the same name but with\n    different types.  However, many SOPs do not let you distinguish between\n    attributes that have the same name, and multiple attributes with the same\n    name are discouraged.  For this reason, you cannot create them with this\n    method."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if transform_as_normal is ", {"text": ["True"], "type": "code"}, " and the\n    default value is not a sequence of 3 floats."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # Create an integer point attribute of size 1 named \"population\", and\n    # create 5 points with attribute values 0, 5, 10, 15, and 20.  This code\n    # will work from inside a Python SOP, but not from the Python shell.\n    geo = hou.pwd().geometry()\n    population_attrib = geo.addAttrib(hou.attribType.Point, \"population\", 0)\n    for i in range(5):\n        point = geo.createPoint()\n        point.setPosition((i, 0, 0))\n        point.setAttribValue(population_attrib, i * 5)\n    "]}, {"indent": 4, "type": "para", "text": ["The following example shows how to copy an existing attribute:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def copyAttrib(attrib, new_name):\n        return attrib.geometry().addAttrib(\n            attrib.type(), new_name, attrib.defaultValue(), attrib.isTransformedAsNormal())\n    "]}, {"indent": 4, "type": "para", "text": ["If ", {"text": ["create_local_variable"], "type": "code"}, " is ", {"text": ["True"], "type": "code"}, ", this function performs the equivalent\n    of the following code:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def addLocalVariable(geo, attrib_name):\n        '''Create a geometry attribute and add a local variable for it.'''\n        # The variable mappings are stored in the varmap attribute's string\n        # table.  This table is different than varmap's current value, which\n        # simply refers to an entry in that table.  So, to ensure an entry\n        # exists in the table, we simply set varmap's value.\n        map_value = \"%s -> %s\" % (attrib_name, attrib_name.upper())\n        if geo.findGlobalAttrib(\"varmap\") is None:\n            geo.addAttrib(hou.attribType.Global, \"varmap\", \"\")\n        geo.setGlobalAttribValue(\"varmap\", map_value)\n    "]}, {"indent": 4, "type": "para", "text": ["See also:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setAttribValue", "text": "", "value": "/hom/hou/Prim#setAttribValue", "fallback_text": "hou.Prim.setAttribValue", "fullpath": "/hom/hou/Prim#setAttribValue", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setAttribValue", "text": "", "value": "/hom/hou/Point#setAttribValue", "fallback_text": "hou.Point.setAttribValue", "fullpath": "/hom/hou/Point#setAttribValue", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setAttribValue", "text": "", "value": "/hom/hou/Prim#setAttribValue", "fallback_text": "hou.Prim.setAttribValue", "fullpath": "/hom/hou/Prim#setAttribValue", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setGlobalAttribValue", "text": "", "value": "/hom/hou/Geometry#setGlobalAttribValue", "fallback_text": "hou.Geometry.setGlobalAttribValue", "fullpath": "/hom/hou/Geometry#setGlobalAttribValue", "scheme": "Hom", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["addAttrib(self, type, name, default_value, transform_as_normal=False, create_local_variable=True)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::addAttrib"}, "type": "methods_item", "id": "addAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new point, primitive, vertex, or global (a.k.a. detail) array \n    attribute. Returns a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object describing the newly created \n    attribute. You would typically call this method from the code of a \n    Python-defined SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/attribType", "fallback_text": "hou.attribType", "fullpath": "/hom/hou/attribType", "scheme": "Hom", "type": "link"}, " value to specify if the new attribute should be\n        a point, primitive, vertex, or global attribute."]}], "indent": 4, "type": "dt", "text": ["type"]}, {"body": [{"indent": 8, "type": "para", "text": ["The new attribute\u2019s name.  Each attribute in the geometry must have\n        a unique name."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/attribData", "fallback_text": "hou.attribData", "fullpath": "/hom/hou/attribData", "scheme": "Hom", "type": "link"}, " value to specify if the new attribute should be\n        an int, float, or string attribute."]}], "indent": 4, "type": "dt", "text": ["data_type"]}, {"body": [{"indent": 8, "type": "para", "text": ["The new attribute\u2019s tuple size."]}], "indent": 4, "type": "dt", "text": ["tuple_size"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if an attribute with this name already\n    exists.  If you are familiar with the C++ Houdini Development Kit (HDK),\n    you know that Houdini can support attributes with the same name but with\n    different types.  However, many SOPs do not let you distinguish between\n    attributes that have the same name, and multiple attributes with the same\n    name are discouraged.  For this reason, you cannot create them with this\n    method."]}], "indent": 0, "text": [{"text": ["addArrayAttrib(self, type, name, data_type, tuple_size=1)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::addArrayAttrib"}, "type": "methods_item", "id": "addArrayAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the global (a.k.a. detail) attribute value for a particular\n    attribute.  The attribute may be specified by name or by ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, "\n    object."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if no attribute exists with this name."]}], "indent": 0, "text": [{"text": ["attribValue(self, name_or_attrib)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ", ", {"text": ["str"], "type": "code"}, ", or ", {"text": ["tuple"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::attribValue", "replaces": "/expressions/detail /expressions/detailattribsize /expressions/details"}, "type": "methods_item", "id": "attribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the global (a.k.a. detail) attribute value for a particular floating\n    point attribute.  The attribute may be specified by name or by\n    ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if no attribute exists with this name\n    or the attribute is not a float of size 1."]}, {"indent": 4, "type": "para", "text": ["In most cases, you\u2019ll just use ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Geometry#attribValue", "fallback_text": "hou.Geometry.attribValue", "fullpath": "/hom/hou/Geometry#attribValue", "scheme": "Hom", "type": "link"}, " to access\n    attribute values.  Houdini uses this method internally to implement\n    attribValue."]}], "indent": 0, "text": [{"text": ["floatAttribValue(self, name_or_attrib)"], "type": "code"}, "  \u2192 ", {"text": ["float"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::floatAttribValue"}, "type": "methods_item", "id": "floatAttribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the global (a.k.a. detail) attribute value for a particular floating\n    point attribute.  The attribute may be specified by name or by\n    ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object.  The return value is a list of floats."]}, {"indent": 4, "type": "para", "text": ["It is valid to call this method when the attribute\u2019s size is 1.  In this\n    case, a list with one element is returned."]}, {"indent": 4, "type": "para", "text": ["See also:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#attribValue", "text": "", "value": "/hom/hou/Geometry#attribValue", "fallback_text": "hou.Geometry.attribValue", "fullpath": "/hom/hou/Geometry#attribValue", "scheme": "Hom", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["floatListAttribValue(self, name_or_attrib)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["float"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::floatListAttribValue"}, "type": "methods_item", "id": "floatListAttribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the global (a.k.a. detail) attribute value for a particular integer\n    attribute of size 1.  The attribute may be specified by name or by\n    ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object.  See ", {"fragment": "#floatAttribValue", "text": "", "value": "/hom/hou/Geometry#floatAttribValue", "fallback_text": "hou.Geometry.floatAttribValue", "fullpath": "/hom/hou/Geometry#floatAttribValue", "scheme": "Hom", "type": "link"}, " for more\n    information."]}], "indent": 0, "text": [{"text": ["intAttribValue(self, name_or_attrib)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::intAttribValue"}, "type": "methods_item", "id": "intAttribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the global (a.k.a. detail) attribute value for a particular integer\n    attribute.  The attribute may be specified by name or by ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, "\n    object.  The return value is a list of ints.  See\n    ", {"fragment": "#floatListAttribValue", "text": "", "value": "/hom/hou/Geometry#floatListAttribValue", "fallback_text": "hou.Geometry.floatListAttribValue", "fullpath": "/hom/hou/Geometry#floatListAttribValue", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["intListAttribValue(self, name_or_attrib)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::intListAttribValue"}, "type": "methods_item", "id": "intListAttribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the global (a.k.a. detail) attribute value for a particular string\n    attribute.  The attribute may be specified by name or by ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, "\n    object.  See ", {"fragment": "#floatAttribValue", "text": "", "value": "/hom/hou/Geometry#floatAttribValue", "fallback_text": "hou.Geometry.floatAttribValue", "fullpath": "/hom/hou/Geometry#floatAttribValue", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["stringAttribValue(self, name_or_attrib)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::stringAttribValue"}, "type": "methods_item", "id": "stringAttribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the global (a.k.a. detail) attribute value for a particular string\n    attribute.  The attribute may be specified by name or by ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, "\n    object.  The return value is a list of strings.  See\n    ", {"fragment": "#floatListAttribValue", "text": "", "value": "/hom/hou/Geometry#floatListAttribValue", "fallback_text": "hou.Geometry.floatListAttribValue", "fullpath": "/hom/hou/Geometry#floatListAttribValue", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["stringListAttribValue(self, name_or_attrib)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::stringListAttribValue"}, "type": "methods_item", "id": "stringListAttribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Set a global (a.k.a. detail) attribute value.  The attribute may be\n    specified by name or by ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object.  You would typically call\n    this method from the code of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if no attribute exists with this name\n    or if the attribute\u2019s data type does not match the value passed in.\n    If the attribute\u2019s size is more than 1, the attribute value must be a\n    sequence of integers/floats, and the size of the sequence must match the\n    attribute\u2019s size."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # This code will work from inside a Python SOP, but not from the Python\n    # shell.\n    geo = hou.pwd().geometry()\n    geo.addAttrib(hou.attribType.Global, \"author\", \"\")\n    geo.addAttrib(hou.attribType.Global, \"version\", (0, 0, 0))\n    geo.setGlobalAttribValue(\"author\", \"Joe\")\n    geo.setGlobalAttribValue(\"version\", (1, 0, 7))\n    "]}, {"indent": 4, "type": "para", "text": ["See also:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#attribValue", "text": "", "value": "/hom/hou/Geometry#attribValue", "fallback_text": "hou.Geometry.attribValue", "fullpath": "/hom/hou/Geometry#attribValue", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setAttribValue", "text": "", "value": "/hom/hou/Point#setAttribValue", "fallback_text": "hou.Point.setAttribValue", "fullpath": "/hom/hou/Point#setAttribValue", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setAttribValue", "text": "", "value": "/hom/hou/Prim#setAttribValue", "fallback_text": "hou.Prim.setAttribValue", "fullpath": "/hom/hou/Prim#setAttribValue", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setAttribValue", "text": "", "value": "/hom/hou/Vertex#setAttribValue", "fallback_text": "hou.Vertex.setAttribValue", "fullpath": "/hom/hou/Vertex#setAttribValue", "scheme": "Hom", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["setGlobalAttribValue(self, name_or_attrib, attrib_value)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setGlobalAttribValue"}, "type": "methods_item", "id": "setGlobalAttribValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the enumerated value ", {"fragment": "#Global", "text": "", "value": "/hom/hou/attribType#Global", "fallback_text": "hou.attribType.Global", "fullpath": "/hom/hou/attribType#Global", "scheme": "Hom", "type": "link"}, ".  Points,\n    primitives, vertices, and geometry support the same set of methods for\n    querying their attributes, and this method is one of them."]}, {"indent": 4, "type": "para", "text": ["See also:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#attribType", "text": "", "value": "/hom/hou/Prim#attribType", "fallback_text": "hou.Prim.attribType", "fullpath": "/hom/hou/Prim#attribType", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#attribType", "text": "", "value": "/hom/hou/Point#attribType", "fallback_text": "hou.Point.attribType", "fullpath": "/hom/hou/Point#attribType", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#attribType", "text": "", "value": "/hom/hou/Vertex#attribType", "fallback_text": "hou.Vertex.attribType", "fullpath": "/hom/hou/Vertex#attribType", "scheme": "Hom", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["attribType(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/attribType", "fallback_text": "hou.attribType", "fullpath": "/hom/hou/attribType", "scheme": "Hom", "type": "link"}, " enum value"], "role": "item", "attrs": {"cppname": "HOM_Geometry::attribType"}, "type": "methods_item", "id": "attribType"}, {"body": [{"indent": 4, "type": "para", "text": ["Rename the point attribute with the specified old name to the new name.\n    This method is typically called from within a Python-defined SOP when the\n    SOP\u2019s geometry is writable."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": ["GeometryPermissionError"], "type": "code"}, " if called on a read-only geometry. \n    Raises ", {"text": ["TypeError"], "type": "code"}, " if ", {"text": ["old_name"], "type": "code"}, " or ", {"text": ["new_name"], "type": "code"}, " is None.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if no such point attribute with the old name\n    exists.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if a point attribute with the new name already\n    exists."]}], "indent": 0, "text": [{"text": ["renamePointAttrib(self, old_name, new_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::renamePointAttrib"}, "type": "methods_item", "id": "renamePointAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Rename the primitive attribute with the specified old name to the new name.\n    This method is typically called from within a Python-defined SOP when the\n    SOP\u2019s geometry is writable."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": ["GeometryPermissionError"], "type": "code"}, " if called on a read-only geometry. \n    Raises ", {"text": ["TypeError"], "type": "code"}, " if ", {"text": ["old_name"], "type": "code"}, " or ", {"text": ["new_name"], "type": "code"}, " is None.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if no such primitive attribute with the old name\n    exists.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if a primitive attribute with the new name already\n    exists."]}], "indent": 0, "text": [{"text": ["renamePrimAttrib(self, old_name, new_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::renamePrimAttrib"}, "type": "methods_item", "id": "renamePrimAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Rename the vertex attribute with the specified old name to the new name.\n    This method is typically called from within a Python-defined SOP when the\n    SOP\u2019s geometry is writable."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": ["GeometryPermissionError"], "type": "code"}, " if called on a read-only geometry. \n    Raises ", {"text": ["TypeError"], "type": "code"}, " if ", {"text": ["old_name"], "type": "code"}, " or ", {"text": ["new_name"], "type": "code"}, " is None.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if no such vertex attribute with the old name\n    exists.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if a vertex attribute with the new name already\n    exists."]}], "indent": 0, "text": [{"text": ["renameVertexAttrib(self, old_name, new_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::renameVertexAttrib"}, "type": "methods_item", "id": "renameVertexAttrib"}, {"body": [{"indent": 4, "type": "para", "text": ["Rename the global attribute with the specified old name to the new name.\n    This method is typically called from within a Python-defined SOP when the\n    SOP\u2019s geometry is writable."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": ["GeometryPermissionError"], "type": "code"}, " if called on a read-only geometry. \n    Raises ", {"text": ["TypeError"], "type": "code"}, " if ", {"text": ["old_name"], "type": "code"}, " or ", {"text": ["new_name"], "type": "code"}, " is None.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if no such global attribute with the old name\n    exists.\n    Raises ", {"text": ["OperationFailed"], "type": "code"}, " if a global attribute with the new name already\n    exists."]}], "indent": 0, "text": [{"text": ["renameGlobalAttrib(self, old_name, new_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::renameGlobalAttrib"}, "type": "methods_item", "id": "renameGlobalAttrib"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Attributes"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Gets the value of an \"intrinsic\", often computed, value of the geometry,\n    such as ", {"text": ["memoryusage"], "type": "code"}, ", ", {"text": ["pointcount"], "type": "code"}, ", ", {"text": ["pointattributes"], "type": "code"}, ", and so on. Raises\n    ", {"text": ["OperationFailed"], "type": "code"}, " if the given intrinsic name does not exist."]}, {"indent": 4, "type": "para", "text": ["You can also view these values in the user interface using the\n    ", {"text": ["geometry spreadsheet"], "fullpath": "/ref/panes/geosheet", "scheme": null, "type": "link", "value": "/ref/panes/geosheet"}, "."]}, {"indent": 4, "type": "para", "text": ["In Houdini, some primitives have \"intrinsic\" values which can\u2019t be accessed\n    directly through the attribute interface. Most intrinsic values are\n    computed, such as ", {"text": ["measuredarea"], "type": "code"}, ", however a few are writeable with the\n    ", {"fragment": "#setIntrinsicValue", "text": ["setIntrinsicValue method"], "value": "#setIntrinsicValue", "fullpath": "/hom/hou/Geometry#setIntrinsicValue", "scheme": null, "type": "link"}, ". For example, sphere\n    primitives have a transform matrix as part of their definition."]}, {"indent": 4, "type": "para", "text": ["You can get a list of the available intrinsic value names with the\n    ", {"fragment": "#intrinsicNames", "text": ["intrinsicNames method"], "value": "#intrinsicNames", "fullpath": "/hom/hou/Geometry#intrinsicNames", "scheme": null, "type": "link"}, ". Different geometry types will have\n    different intrinsic values available."]}], "indent": 0, "text": [{"text": ["intrinsicValue(self, intrinsic_name)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ", ", {"text": ["str"], "type": "code"}, ", or ", {"text": ["tuple"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::intrinsicValue"}, "type": "methods_item", "id": "intrinsicValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of strings representing the intrinsic values available for\n    this geometry. Different geometry types will have different intrinsic values\n    available. You can then get or set the value using\n    ", {"fragment": "#intrinsicValue", "text": ["intrinsicValue"], "value": "#intrinsicValue", "fullpath": "/hom/hou/Geometry#intrinsicValue", "scheme": null, "type": "link"}, " and/or ", {"fragment": "#setIntrinsicValue", "text": ["setIntrinsicValue"], "value": "#setIntrinsicValue", "fullpath": "/hom/hou/Geometry#setIntrinsicValue", "scheme": null, "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["See the ", {"fragment": "#intrinsicValue", "text": ["intrinsicValue method"], "value": "#intrinsicValue", "fullpath": "/hom/hou/Geometry#intrinsicValue", "scheme": null, "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["intrinsicNames(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::intrinsicNames"}, "type": "methods_item", "id": "intrinsicNames"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a dictionary mapping intrinsic names to their values."]}], "indent": 0, "text": [{"text": ["intrinsicValueDict(self)"], "type": "code"}, "  \u2192 ", {"text": ["dict"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}, " to ", {"text": ["value"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::intrinsicValueDict"}, "type": "methods_item", "id": "intrinsicValueDict"}, {"body": [{"indent": 4, "type": "para", "text": ["Some \"intrinsic\" values can be modified. For example, you change the\n    internal size and rotation (transform) of a sphere primitive by passing a 16\n    float tuple representing the transform to ", {"text": ["setIntrinsicValue"], "type": "code"}, ". Raises\n    ", {"text": ["Error"], "type": "code"}, " if the intrinsic is not writeable or does not accept the passed\n    value, or if the given intrinsic name does not exist."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Modifying the geometry directly will lock the geometry\u2019s parent node."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 4, "type": "para", "text": ["See the ", {"fragment": "#intrinsicValue", "text": ["intrinsicValue method"], "value": "#intrinsicValue", "fullpath": "/hom/hou/Geometry#intrinsicValue", "scheme": null, "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["setIntrinsicValue(self, intrinsic_name, value)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setIntrinsicValue"}, "type": "methods_item", "id": "setIntrinsicValue"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns whether the intrinsic is read-only or can be modified with\n    ", {"text": ["setIntrinsicValue()"], "type": "code"}]}], "indent": 0, "text": [{"text": ["intrinsicReadOnly(self, intrinsic_name)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"status": "nd", "cppname": "HOM_Prim::intrinsicReadOnly"}, "type": "methods_item", "id": "intrinsicReadOnly"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns the intrinsic value tuple size."]}], "indent": 0, "text": [{"text": ["intrinsicSize(self, intrinsic_name)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"status": "nd", "cppname": "HOM_Prim::intrinsicSize"}, "type": "methods_item", "id": "intrinsicSize"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Intrinsics"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [], "indent": 0, "text": [{"text": ["averagePointAttribValue(self, attrib_name, index)"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::averagePointAttribValue", "replaces": "/expressions/pointavg"}, "type": "methods_item", "id": "averagePointAttribValue"}, {"body": [], "indent": 0, "text": [{"text": ["averagePointAttribValueByType(self, attrib_type, index)"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::averagePointAttribValueByType", "replaces": "/expressions/pointavg"}, "type": "methods_item", "id": "averagePointAttribValueByType"}, {"body": [], "indent": 0, "text": [{"text": ["averagePrimAttribValue(self, attrib_name, index)"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::averagePrimAttribValue"}, "type": "methods_item", "id": "averagePrimAttribValue"}, {"body": [], "indent": 0, "text": [{"text": ["averagePrimAttribValueByType(self, attrib_type, index)"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::averagePrimAttribValueByType"}, "type": "methods_item", "id": "averagePrimAttribValueByType"}, {"body": [], "indent": 0, "text": [{"text": ["averageVertexAttribValue(self, attrib_name, index)"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::averageVertexAttribValue"}, "type": "methods_item", "id": "averageVertexAttribValue"}, {"body": [], "indent": 0, "text": [{"text": ["averageVertexAttribValueByType(self, attrib_type, index)"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::averageVertexAttribValueByType"}, "type": "methods_item", "id": "averageVertexAttribValueByType"}, {"body": [{"indent": 4, "type": "para", "text": ["Return an axis-aligned 3D bounding box that is sized and positioned \n    to include the points specified by the point pattern.  If the pattern\n    is blank, all points will be included."]}, {"indent": 4, "type": "para", "text": ["Some primitives, such as spheres, extend beyond their points. This\n    extension will not be included."]}], "indent": 0, "text": [{"text": ["pointBoundingBox(self, pointpattern)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/BoundingBox", "fallback_text": "hou.BoundingBox", "fullpath": "/hom/hou/BoundingBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointBoundingBox", "replaces": "/expressions/bbox"}, "type": "methods_item", "id": "pointBoundingBox"}, {"body": [{"indent": 4, "type": "para", "text": ["Return an axis-aligned 3D bounding box that is sized and positioned \n    to include the primitives specified by the primitive pattern.  If the\n    pattern is blank, all primitives will be included."]}, {"indent": 4, "type": "para", "text": ["Some primitives, such as spheres, extend beyond their points. This\n    extension will be included."]}], "indent": 0, "text": [{"text": ["primBoundingBox(self, primpattern)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/BoundingBox", "fallback_text": "hou.BoundingBox", "fullpath": "/hom/hou/BoundingBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primBoundingBox", "replaces": "/expressions/bbox"}, "type": "methods_item", "id": "primBoundingBox"}, {"body": [{"indent": 4, "type": "para", "text": ["Return an axis-aligned 3D bounding box that is sized and positioned to be\n    large enough to hold this geometry."]}], "indent": 0, "text": [{"text": ["boundingBox(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/BoundingBox", "fallback_text": "hou.BoundingBox", "fullpath": "/hom/hou/BoundingBox", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::boundingBox", "replaces": "/expressions/bbox"}, "type": "methods_item", "id": "boundingBox"}, {"body": [], "indent": 0, "text": [{"text": ["centroid(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Vector3", "fallback_text": "hou.Vector3", "fullpath": "/hom/hou/Vector3", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::centroid", "replaces": "/expressions/centroid"}, "type": "methods_item", "id": "centroid"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the average over all points in ", {"text": ["geometry"], "type": "var"}, " of the minimum\n    distance to the point set of ", {"text": ["self"], "type": "var"}]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A transform to be applied to all points in this geometry."]}], "indent": 4, "type": "dt", "text": ["local_transform"]}, {"body": [{"indent": 8, "type": "para", "text": ["The geometry to find distances from."]}], "indent": 4, "type": "dt", "text": ["geometry"]}, {"body": [{"indent": 8, "type": "para", "text": ["A transform to be applied to all points in ", {"text": ["geometry"], "type": "var"}, "."]}], "indent": 4, "type": "dt", "text": ["geometry_transform"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if ", {"text": ["geometry"], "type": "var"}, " has no vertices."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    query_geometry = query_node.geometry()\n    queried_geometry = queried_node.geometry()\n\n    # Return the average over all points in <queried_geometry> of the minimum\n    # distance to the point set of <query_geometry>\n    query_geometry.averageMinDistance(\n        query_node.worldTransform(),\n        queried_geometry,\n        queried_node.worldTransform())\n    "]}], "indent": 0, "text": [{"text": ["averageMinDistance(self, local_transform, geometry, geometry_transform)"], "type": "code"}, "  \u2192 ", {"text": ["float"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::averageMinDistance"}, "type": "methods_item", "id": "averageMinDistance"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the average edge length of the mesh."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if mesh does not contain any edges."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # Return the average edge length.\n    geo.averageEdgeLength()\n    "]}], "indent": 0, "text": [{"text": ["averageEdgeLength(self)"], "type": "code"}, "  \u2192 ", {"text": ["float"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::averageEdgeLength"}, "type": "methods_item", "id": "averageEdgeLength"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Averages"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Create a new point located at (0, 0, 0) and return the corresponding\n    ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " object.  You would typically call this method from the code\n    of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["If the geometry contains point attributes, the new point receives the\n    default values for those attributes."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#addAttrib", "text": "", "value": "/hom/hou/Geometry#addAttrib", "fallback_text": "hou.Geometry.addAttrib", "fullpath": "/hom/hou/Geometry#addAttrib", "scheme": "Hom", "type": "link"}, ", ", {"fragment": "#createPolygon", "text": "", "value": "/hom/hou/Geometry#createPolygon", "fallback_text": "hou.Geometry.createPolygon", "fullpath": "/hom/hou/Geometry#createPolygon", "scheme": "Hom", "type": "link"}, ", and\n    ", {"fragment": "#addVertex", "text": "", "value": "/hom/hou/Face#addVertex", "fallback_text": "hou.Face.addVertex", "fullpath": "/hom/hou/Face#addVertex", "scheme": "Hom", "type": "link"}, " for examples."]}], "indent": 0, "text": [{"text": ["createPoint(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createPoint"}, "type": "methods_item", "id": "createPoint"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a set of points located at the specified positions and return\n    a tuple of the new ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " objects.  You would typically call this\n    method from the code of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": [{"text": ["point_positions"], "type": "code"}, " can be either a tuple of ", {"text": "", "value": "/hom/hou/Vector3", "fallback_text": "hou.Vector3", "fullpath": "/hom/hou/Vector3", "scheme": "Hom", "type": "link"}, " objects or a\n    tuple of 3-tuple floating point numbers.  For example, if ", {"text": ["point_positions"], "type": "code"}, "\n    is ", {"text": ["((0, 1, 2), (1, 2, 3))"], "type": "code"}, " then this method will create 2 points with one\n    positioned at (0, 1, 2) and the other at (1, 2, 3)."]}, {"indent": 4, "type": "para", "text": ["If the geometry contains point attributes, the new points receive the\n    default values for those attributes."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable.\n    Raises ", {"text": "", "value": "/hom/hou/InvalidSize", "fallback_text": "hou.InvalidSize", "fullpath": "/hom/hou/InvalidSize", "scheme": "Hom", "type": "link"}, " if one of the specified point positions does\n    not contain 3 values (for x, y, z)."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#addAttrib", "text": "", "value": "/hom/hou/Geometry#addAttrib", "fallback_text": "hou.Geometry.addAttrib", "fullpath": "/hom/hou/Geometry#addAttrib", "scheme": "Hom", "type": "link"}, ", ", {"fragment": "#createPolygons", "text": "", "value": "/hom/hou/Geometry#createPolygons", "fallback_text": "hou.Geometry.createPolygons", "fullpath": "/hom/hou/Geometry#createPolygons", "scheme": "Hom", "type": "link"}, ", and\n    ", {"fragment": "#addVertex", "text": "", "value": "/hom/hou/Face#addVertex", "fallback_text": "hou.Face.addVertex", "fullpath": "/hom/hou/Face#addVertex", "scheme": "Hom", "type": "link"}, " for examples."]}], "indent": 0, "text": [{"text": ["createPoints(self, point_positions)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createPoints"}, "type": "methods_item", "id": "createPoints"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new polygon and return the corresponding ", {"text": "", "value": "/hom/hou/Polygon", "fallback_text": "hou.Polygon", "fullpath": "/hom/hou/Polygon", "scheme": "Hom", "type": "link"}, "\n    object.  You would typically call this method from the code of a\n    Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["The newly created polygon has no vertices.  Use ", {"fragment": "#addVertex", "text": "", "value": "/hom/hou/Face#addVertex", "fallback_text": "hou.Face.addVertex", "fullpath": "/hom/hou/Face#addVertex", "scheme": "Hom", "type": "link"}, "\n    to add them.  The polygon is also closed (see ", {"fragment": "#isClosed", "text": "", "value": "/hom/hou/Face#isClosed", "fallback_text": "hou.Face.isClosed", "fullpath": "/hom/hou/Face#isClosed", "scheme": "Hom", "type": "link"}, "\n    for more information)."]}, {"indent": 4, "type": "para", "text": ["If the geometry contains primitive attributes, the new polygon receives the\n    default values for those attributes."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    geo = hou.pwd().geometry()\n    poly = geo.createPolygon()\n    for position in (0,0,0), (1,0,0), (0,1,0):\n        point = geo.createPoint()\n        point.setPosition(position)\n        poly.addVertex(point)\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#addVertex", "text": "", "value": "/hom/hou/Face#addVertex", "fallback_text": "hou.Face.addVertex", "fullpath": "/hom/hou/Face#addVertex", "scheme": "Hom", "type": "link"}, " for a slightly more complicated example."]}], "indent": 0, "text": [{"text": ["createPolygon(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Polygon", "fallback_text": "hou.Polygon", "fullpath": "/hom/hou/Polygon", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createPolygon"}, "type": "methods_item", "id": "createPolygon"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a set of polygons with the specified points as vertices and return\n    a tuple of the new ", {"text": "", "value": "/hom/hou/Polygon", "fallback_text": "hou.Polygon", "fullpath": "/hom/hou/Polygon", "scheme": "Hom", "type": "link"}, " objects.  You would typically call\n    this method from the code of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": [{"text": ["points"], "type": "code"}, " can be either a tuple of tuples of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " objects\n    or a tuple of tuples of integers representing the point numbers.  For\n    example, if ", {"text": ["points"], "type": "code"}, " is ", {"text": ["((0, 1, 2), (3, 4, 5, 6))"], "type": "code"}, " then this method will\n    create 2 polygons with one having points 0, 1 and 2 as its vertices and the\n    other one having points 3, 4, 5 and 6 as its vertices."]}, {"indent": 4, "type": "para", "text": ["The created polygons are closed (see ", {"fragment": "#isClosed", "text": "", "value": "/hom/hou/Face#isClosed", "fallback_text": "hou.Face.isClosed", "fullpath": "/hom/hou/Face#isClosed", "scheme": "Hom", "type": "link"}, " for more\n    information)."]}, {"indent": 4, "type": "para", "text": ["If the geometry contains primitive attributes, then the new polygons\n    receive the default values for those attributes."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable.\n    Raises ", {"text": "", "value": "/hom/hou/InvalidSize", "fallback_text": "hou.InvalidSize", "fullpath": "/hom/hou/InvalidSize", "scheme": "Hom", "type": "link"}, " if one of the specified point tuples does not\n    contain at least 3 elements.  Raises ", {"text": "", "value": "/hom/hou/InvalidInput", "fallback_text": "hou.InvalidInput", "fullpath": "/hom/hou/InvalidInput", "scheme": "Hom", "type": "link"}, " if one of the\n    point numbers or ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " objects do not exist in the geometry."]}, {"indent": 4, "type": "para", "text": ["Example:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # Create 6 points in the geometry.\n    geo = hou.pwd().geometry()\n    point_positions = (\n        (1, 0, 0), (0, 1, 0), (0, 0, 1),\n        (1, 1, 0), (1, 0, 1), (0, 1, 1),\n    )\n    points = geo.createPoints(point_positions)\n\n    # Create 2 polygons.\n    # The first polygon uses the first 3 points in the geometry as its vertices.\n    # The second polygon uses the last 3 points in the geometry as its vertices.\n    polygons = geo.createPolygons(\n        ((points[0], points[1], points[2]), (points[3], points[4], points[5])))\n    "]}], "indent": 0, "text": [{"text": ["createPolygons(self, points)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Polygon", "fallback_text": "hou.Polygon", "fullpath": "/hom/hou/Polygon", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createPolygons"}, "type": "methods_item", "id": "createPolygons"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new tetrahedron and return the corresponding ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, "\n    object.  You would typically call this method from the code of a\n    Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["The newly created tetrahedron has four vertices and new points\n    have been allocated for them.  To build a tetrahedron out of existin\n    points, use ", {"fragment": "#createTetrahedronInPlace", "text": "", "value": "Hom.hou.Geometry#createTetrahedronInPlace", "fullpath": "/hom/hou/Hom.hou.Geometry#createTetrahedronInPlace", "scheme": null, "type": "link"}]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}], "indent": 0, "text": [{"text": ["createTetrahedron(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createTetrahedron"}, "type": "methods_item", "id": "createTetrahedron"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new tetrahedron and return the corresponding ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, "\n    object.  You would typically call this method from the code of a\n    Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["The newly created tetrahedron has four vertices and uses the points\n    that have been passed into it."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}], "indent": 0, "text": [{"text": ["createTetrahedronInPlace(self, p0, p1, p2, p3)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createTetrahedronInPlace"}, "type": "methods_item", "id": "createTetrahedronInPlace"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new NURBS with the specified number of vertices and return it.\n    You would typically call this method from the code of a Python-defined SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The number of verticies in the curve.  A new point is added to the\n        geometry for each vertex, and this point is located at the origin until\n        you change its position.  You can also add more vertices with\n        ", {"fragment": "#addVertex", "text": "", "value": "/hom/hou/Face#addVertex", "fallback_text": "hou.Face.addVertex", "fullpath": "/hom/hou/Face#addVertex", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 8, "type": "para", "text": ["The minimum number of vertices for a NURBS curve is identical to its\n        order. So for the default order of 4, the curve must have a minimum of\n        4 vertices. If you specify too few vertices, this method raises\n        ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}], "indent": 4, "type": "dt", "text": ["num_vertices"]}, {"body": [{"indent": 8, "type": "para", "text": ["Controls if the curve is open or closed; see ", {"fragment": "#isClosed", "text": "", "value": "/hom/hou/Face#isClosed", "fallback_text": "hou.Face.isClosed", "fullpath": "/hom/hou/Face#isClosed", "scheme": "Hom", "type": "link"}, "\n        for more information.  If not specified, the resulting curve is open.\n        This behavior is different from ", {"fragment": "#createPolygon", "text": "", "value": "/hom/hou/Geometry#createPolygon", "fallback_text": "hou.Geometry.createPolygon", "fullpath": "/hom/hou/Geometry#createPolygon", "scheme": "Hom", "type": "link"}, ",\n        where the new polygon is closed.  You can also open or close it with\n        ", {"fragment": "#setIsClosed", "text": "", "value": "/hom/hou/Face#setIsClosed", "fallback_text": "hou.Face.setIsClosed", "fullpath": "/hom/hou/Face#setIsClosed", "scheme": "Hom", "type": "link"}, "."]}], "indent": 4, "type": "dt", "text": ["is_closed"]}, {"body": [{"indent": 7, "type": "para", "text": ["Specifies the curve\u2019s order. The default order is 4, corresponding to\n       a cubic NURBS curve. An order of 2, the lowest order, will give a curve\n       with linear segments."]}], "indent": 4, "type": "dt", "text": ["order"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["If the geometry contains primitive attributes, the new curve receives the\n    default values for those attributes."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # This code will work from inside a Python SOP, but not from the Python\n    # shell.\n    geo = hou.pwd().geometry()\n    curve = geo.createNURBSCurve(10)\n    i = 0\n    for vertex in curve.vertices():\n        vertex.point().setPosition((i, i % 3, 0))\n        i = i + 1\n    "]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"indent": 4, "type": "para", "text": ["See also:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#vertices", "text": "", "value": "/hom/hou/Prim#vertices", "fallback_text": "hou.Prim.vertices", "fullpath": "/hom/hou/Prim#vertices", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#setPosition", "text": "", "value": "/hom/hou/Point#setPosition", "fallback_text": "hou.Point.setPosition", "fullpath": "/hom/hou/Point#setPosition", "scheme": "Hom", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["createNURBSCurve(self, num_vertices=4, is_closed=False, order=4)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Face", "fallback_text": "hou.Face", "fullpath": "/hom/hou/Face", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createNURBSCurve"}, "type": "methods_item", "id": "createNURBSCurve"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new Bezier curve with the specified number of vertices and\n    return it.  You would typically call this method from the code of a\n    Python-defined SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The number of verticies in the curve.  A new point is added to the\n        geometry for each vertex, and this point is located at the origin until\n        you change its position.  You can also add more vertices with\n        ", {"fragment": "#addVertex", "text": "", "value": "/hom/hou/Face#addVertex", "fallback_text": "hou.Face.addVertex", "fullpath": "/hom/hou/Face#addVertex", "scheme": "Hom", "type": "link"}, "."]}], "indent": 4, "type": "dt", "text": ["num_vertices"]}, {"body": [{"indent": 8, "type": "para", "text": ["Controls if the curve is open or closed; see ", {"fragment": "#isClosed", "text": "", "value": "/hom/hou/Face#isClosed", "fallback_text": "hou.Face.isClosed", "fullpath": "/hom/hou/Face#isClosed", "scheme": "Hom", "type": "link"}, "\n        for more information.  If not specified, the resulting curve is open.\n        This behavior is different from ", {"fragment": "#createPolygon", "text": "", "value": "/hom/hou/Geometry#createPolygon", "fallback_text": "hou.Geometry.createPolygon", "fullpath": "/hom/hou/Geometry#createPolygon", "scheme": "Hom", "type": "link"}, ",\n        where the new polygon is closed. "]}], "indent": 4, "type": "dt", "text": ["is_closed"]}, {"body": [{"indent": 7, "type": "para", "text": ["Specifies the curve\u2019s order. The default order is 4, corresponding to\n       a cubic Bezier curve. An order of 2, the lowest order, will give a curve\n       with linear segments."]}], "indent": 4, "type": "dt", "text": ["order"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["An open Bezier curve must have ", {"text": ["(order - 1) * n + 1"], "type": "code"}, " vertices for some\n    integer ", {"text": ["n>=1"], "type": "code"}, " (so valid values for order 4 curves are 4, 7, 10, etc.).  \n    A closed Bezier curve must have ", {"text": ["(order - 1) * n"], "type": "code"}, " vertices (e.g. 3, 6, 9, etc. \n    for order 4 curve). This restriction does not apply to curves of order 2, however. "]}, {"indent": 4, "type": "para", "text": ["As a consequence, you cannot use ", {"fragment": "#setIsClosed", "text": "", "value": "/hom/hou/Face#setIsClosed", "fallback_text": "hou.Face.setIsClosed", "fullpath": "/hom/hou/Face#setIsClosed", "scheme": "Hom", "type": "link"}, " on non-linear \n    Bezier curves, since the number of vertices would need to change."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#createNURBSCurve", "text": "", "value": "/hom/hou/Geometry#createNURBSCurve", "fallback_text": "hou.Geometry.createNURBSCurve", "fullpath": "/hom/hou/Geometry#createNURBSCurve", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["createBezierCurve(self, num_vertices=4, is_closed=False, order=4)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Face", "fallback_text": "hou.Face", "fullpath": "/hom/hou/Face", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createBezierCurve"}, "type": "methods_item", "id": "createBezierCurve"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a NURBS surface in the XY plane centered at the origin with size\n    (1, 1) and return it.  You would typically call this method from the code\n    of a Python-defined SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Determines the size of the 2D array of vertices defining the control\n        points of the surface. The number of cols and rows in each direction,\n        must be equal to or larger than the U and V orders, respectively."]}], "indent": 4, "type": "dt", "text": ["rows, cols"]}, {"body": [{"indent": 8, "type": "para", "text": ["Controls if the surface is open or closed in each of the U and V \n        directionss; see ", {"fragment": "#isClosedInU", "text": "", "value": "/hom/hou/Surface#isClosedInU", "fallback_text": "hou.Surface.isClosedInU", "fullpath": "/hom/hou/Surface#isClosedInU", "scheme": "Hom", "type": "link"}, " for more information.  \n        If not specified, the default behavior is to build an open surface."]}], "indent": 4, "type": "dt", "text": ["is_closed_in_u, is_closed_in_v"]}, {"body": [{"indent": 7, "type": "para", "text": ["Specifies the surface\u2019s order in each of the U and V directionss. \n       The default order for both is 4, corresponding to a cubic NURBS surface. \n       An order of 2, the lowest order, will give a surface with linear segments,\n       essentially a mesh."]}], "indent": 4, "type": "dt", "text": ["order_u, order_v"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["If the geometry contains primitive attributes, the new surface receives the\n    default values for those attributes."]}, {"indent": 4, "type": "para", "text": ["You can move or resize the surface using ", {"fragment": "#transformPrims", "text": "", "value": "/hom/hou/Geometry#transformPrims", "fallback_text": "hou.Geometry.transformPrims", "fullpath": "/hom/hou/Geometry#transformPrims", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the number of rows and/or columns\n    is invalid."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # This code will work from inside a Python SOP, but not from the Python\n    # shell.\n    geo = hou.pwd().geometry()\n\n    # Create a surface with a 10x10 grid of vertices.\n    surf = geo.createNURBSSurface(10, 10)\n\n    # Initially, the center is at (0, 0, 0), size is (1, 1, 1), on the XY\n    # plane.  Scale to (20, 10) and rotate into the XZ plane.\n    geo.transformPrims((surf,),\n        hou.hmath.buildScale((20, 10, 1)) *\n        hou.hmath.buildRotateAboutAxis((1, 0, 0), 90))\n    "]}, {"indent": 4, "type": "para", "text": ["See also:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#transformPrims", "text": "", "value": "/hom/hou/Geometry#transformPrims", "fallback_text": "hou.Geometry.transformPrims", "fullpath": "/hom/hou/Geometry#transformPrims", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"text": "", "value": "/hom/hou/Matrix4", "fallback_text": "hou.Matrix4", "fullpath": "/hom/hou/Matrix4", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"text": "", "value": "/hom/hou/hmath", "fallback_text": "hou.hmath", "fullpath": "/hom/hou/hmath", "scheme": "Hom", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["createNURBSSurface(self, rows, cols, is_closed_in_u=False, is_closed_in_v=False)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Surface", "fallback_text": "hou.Surface", "fullpath": "/hom/hou/Surface", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createNURBSSurface"}, "type": "methods_item", "id": "createNURBSSurface"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a Bezier surface in the XY plane centered at the origin with size\n    (1, 1) and return it.  You would typically call this method from the code\n    of a Python-defined SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Determines the size of the 2D array of vertices defining the control\n        points of the surface. "]}, {"indent": 8, "type": "para", "text": ["Note that the number of rows corresponds to ", {"text": ["v"], "type": "code"}, " and the number or\n        columns corresponds to ", {"text": ["u"], "type": "code"}, ", which can be slightly confusing.  For\n        example, ", {"text": ["geo.createBezierSurface(9, 7, is_closed_in_u=False,\n        is_closed_in_v=True)"], "type": "code"}, " is valid, but ", {"text": ["geo.createBezierSurface(9, 7,\n        is_closed_in_u=True, is_closed_in_v=False)"], "type": "code"}, " raises\n        ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}], "indent": 4, "type": "dt", "text": ["rows, cols"]}, {"body": [{"indent": 8, "type": "para", "text": ["Determines if it is open or closed in each of the ", {"text": ["u"], "type": "code"}, " and ", {"text": ["v"], "type": "code"}, "\n        directions; see ", {"fragment": "#isClosedInU", "text": "", "value": "/hom/hou/Surface#isClosedInU", "fallback_text": "hou.Surface.isClosedInU", "fullpath": "/hom/hou/Surface#isClosedInU", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 4, "type": "dt", "text": ["is_closed_in_u, is_closed_in_v"]}, {"body": [{"indent": 7, "type": "para", "text": ["Specifies the surface\u2019s order in of the U and V directions. \n       The default order for both is 4, corresponding to a cubic NURBS surface. \n       An order of 2, the lowest order, will give a surface with linear segments,\n       essentially a mesh."]}], "indent": 4, "type": "dt", "text": ["order_u, order_v"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["As with Bezier curves, a Bezier surface has some restrictions on the point\n    count in each of the U and V directions. For a given direction; if it\u2019s \n    open the number of points in the direction must be ", {"text": ["(order - 1) * n + 1"], "type": "code"}, "\n    for some integer ", {"text": ["n >= 1"], "type": "code"}, " (e.g. 4, 7, 10, \u2026). If it\u2019s open, the number of\n    points must be ", {"text": ["(order - 1) * n"], "type": "code"}, " where ", {"text": ["n >= 1"], "type": "code"}, " in that direction (e.g. \n    2, 4, 6, .. for order 3)."]}, {"indent": 4, "type": "para", "text": ["You can move or resize the surface using ", {"fragment": "#transformPrims", "text": "", "value": "/hom/hou/Geometry#transformPrims", "fallback_text": "hou.Geometry.transformPrims", "fullpath": "/hom/hou/Geometry#transformPrims", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["If the geometry contains primitive attributes, the new surface receives the\n    default values for those attributes."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import math\n\n    # This code will work from inside a Python SOP, but not from the Python\n    # shell.\n    geo = hou.pwd().geometry()\n\n    # Build a tube-like object about the y axis.\n    num_rows, num_cols = (10, 9)\n    surf = geo.createBezierSurface(num_rows, num_cols, is_closed_in_u=True)\n    for v_index in range(num_rows):\n        for u_index in range(num_cols):\n            angle = u_index * (2.0 * math.pi) / num_cols\n            surf.vertex(u_index, v_index).point().setPosition(\n                (math.cos(angle), v_index / float(num_cols-1), math.sin(angle)))\n    "]}], "indent": 0, "text": [{"text": ["createBezierSurface(self, rows, cols, is_closed_in_u=False, is_closed_in_v=False)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Surface", "fallback_text": "hou.Surface", "fullpath": "/hom/hou/Surface", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createBezierSurface"}, "type": "methods_item", "id": "createBezierSurface"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a quadrilateral mesh surface in the XY plane centered at the origin\n    with size (1, 1) and return it.  You would typically call this method from\n    the code of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["Note that a mesh object is not the same as a set of polygons defining the\n    same shape.  A mesh object is a single primitive."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#createNURBSSurface", "text": "", "value": "/hom/hou/Geometry#createNURBSSurface", "fallback_text": "hou.Geometry.createNURBSSurface", "fullpath": "/hom/hou/Geometry#createNURBSSurface", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["createMeshSurface(self, rows, cols, is_closed_in_u=False, is_closed_in_v=False)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Surface", "fallback_text": "hou.Surface", "fullpath": "/hom/hou/Surface", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createMeshSurface"}, "type": "methods_item", "id": "createMeshSurface"}, {"body": [{"indent": 4, "type": "para", "text": ["Given the x, y, and z resolution (or size) of a voxel array, add a new\n    volume primitive to the geometry and return it.  The values in the new\n    volume\u2019s voxels are all zero."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["Integers greater than zero that specify the size of the voxel array\n        in one dimension.  Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if any of these\n        values are not positive."]}], "indent": 4, "type": "dt", "text": ["xres, yres, zres"]}, {"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/BoundingBox", "fallback_text": "hou.BoundingBox", "fullpath": "/hom/hou/BoundingBox", "scheme": "Hom", "type": "link"}, " that specifies the volume\u2019s 3D size.  Note that\n        this size is independent of the volume\u2019s voxel resolution.  If\n        this parameter is None, Houdini uses a bounding box going from\n        (-1,-1,-1) to (1,1,1)."]}], "indent": 4, "type": "dt", "text": ["bounding_box"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["createVolume(self, xres, yres, zres, bounding_box=None)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Volume", "fallback_text": "hou.Volume", "fullpath": "/hom/hou/Volume", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createVolume"}, "type": "methods_item", "id": "createVolume"}, {"body": [], "indent": 0, "text": [{"text": ["createMetaball(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Metaball", "fallback_text": "hou.Metaball", "fullpath": "/hom/hou/Metaball", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::createMetaball"}, "type": "methods_item", "id": "createMetaball"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["A string containing the name of a type of packed primitive.\n        Typical examples are ", {"text": ["\"PackedDisk\""], "type": "code"}, " (on-disk geometry file)\n        or ", {"text": ["\"AlembicRef\""], "type": "code"}, " (Alembic file)."]}, {"indent": 8, "type": "para", "text": ["To see a complete list of possible ", {"text": ["typename"], "type": "code"}, " values,\n        run ", {"text": ["ginfo -P"], "type": "code"}, " on a Houdini tools command line."]}], "indent": 4, "type": "dt", "text": [{"text": ["typename"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["See ", {"text": "", "value": "/hom/hou/PackedPrim", "fallback_text": "hou.PackedPrim", "fullpath": "/hom/hou/PackedPrim", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["createPacked(self, typename)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/PackedPrim", "fallback_text": "hou.PackedPrim", "fullpath": "/hom/hou/PackedPrim", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createPacked"}, "type": "methods_item", "id": "createPacked"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Creation"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Delete a sequence of primitives.  You would typically call this method\n    from the code of a Python-defined SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["if ", {"text": ["True"], "type": "code"}, ", the primitive will be deleted but its points will remain."]}], "indent": 4, "type": "dt", "text": ["keep_points"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["To delete a single primitive, pass in a sequence with one primitive."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # Delete every other primitive:\n    prims = [p for p in geo.prims() if p.number() % 2 == 0]\n    geo.deletePrims(prims)\n    \n    # Delete the first primitive:\n    geo.deletePrims([geo.iterPrims()[0]])\n    "]}], "indent": 0, "text": [{"text": ["deletePrims(self, prims, keep_points=False)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::deletePrims"}, "type": "methods_item", "id": "deletePrims"}, {"body": [{"indent": 4, "type": "para", "text": ["Delete a sequence of points.  You would typically call this method\n    from the code of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["Note that Houdini will delete any vertices that reference the point.\n    For example, suppose you have a box with 6 polygons, each with 4 vertices.\n    Also suppose that each point on the box is shared by 3 vertices on 3\n    separate polygons.  If you delete one of those points, Houdini will remove\n    each of those vertices from their corresponding polygons, leaving 3\n    polygons with 4 vertices and 3 polygons with 3 vertices."]}, {"indent": 4, "type": "para", "text": ["To delete a single primitive, pass in a sequence with one point."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not modifiable."]}], "indent": 0, "text": [{"text": ["deletePoints(self, points)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::deletePoints"}, "type": "methods_item", "id": "deletePoints"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Deletion"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return the point group with the given name, or ", {"text": ["None"], "type": "code"}, " if no such group\n    exists."]}], "indent": 0, "text": [{"text": ["findPointGroup(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/PointGroup", "fallback_text": "hou.PointGroup", "fullpath": "/hom/hou/PointGroup", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findPointGroup"}, "type": "methods_item", "id": "findPointGroup"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the point groups in the geometry."]}, {"indent": 4, "type": "para", "text": ["The following function returns the names of all the groups in the\n    geometry:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def pointGroupNames(geometry):\n        return [group.name() for group in geometry.pointGroups()]\n    "]}], "indent": 0, "text": [{"text": ["pointGroups(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/PointGroup", "fallback_text": "hou.PointGroup", "fullpath": "/hom/hou/PointGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointGroups", "replaces": "/expressions/pointgrouplist"}, "type": "methods_item", "id": "pointGroups"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new point group in this geometry."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the new group.  Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if a\n        group with this name already exists."]}], "indent": 4, "type": "dt", "text": [{"text": ["name"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Whether or not the new group should be ordered.  See\n        ", {"text": "", "value": "/hom/hou/PointGroup", "fallback_text": "hou.PointGroup", "fullpath": "/hom/hou/PointGroup", "scheme": "Hom", "type": "link"}, " for more information about ordered groups."]}], "indent": 4, "type": "dt", "text": [{"text": ["is_ordered"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Use ", {"fragment": "#destroy", "text": "", "value": "/hom/hou/PointGroup#destroy", "fallback_text": "hou.PointGroup.destroy", "fullpath": "/hom/hou/PointGroup#destroy", "scheme": "Hom", "type": "link"}, " to remove a primitive group from the\n    geometry."]}], "indent": 0, "text": [{"text": ["createPointGroup(self, name, is_ordered=False)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/PointGroup", "fallback_text": "hou.PointGroup", "fullpath": "/hom/hou/PointGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createPointGroup"}, "type": "methods_item", "id": "createPointGroup"}, {"body": [], "indent": 0, "text": [{"text": ["findPointGroups(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/PointGroup", "fallback_text": "hou.PointGroup", "fullpath": "/hom/hou/PointGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::findPointGroups", "replaces": "/expressions/pointgroupmask"}, "type": "methods_item", "id": "findPointGroups"}, {"body": [{"indent": 4, "type": "para", "text": ["Return the primitive group with the given name, or ", {"text": ["None"], "type": "code"}, " if no such group\n    exists."]}], "indent": 0, "text": [{"text": ["findPrimGroup(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/PrimGroup", "fallback_text": "hou.PrimGroup", "fullpath": "/hom/hou/PrimGroup", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findPrimGroup"}, "type": "methods_item", "id": "findPrimGroup"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the primitive groups in the geometry."]}], "indent": 0, "text": [{"text": ["primGroups(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/PrimGroup", "fallback_text": "hou.PrimGroup", "fullpath": "/hom/hou/PrimGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primGroups", "replaces": "/expressions/primgrouplist"}, "type": "methods_item", "id": "primGroups"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new primitive group in this geometry."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the new group.  Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if a\n        group with this name already exists."]}], "indent": 4, "type": "dt", "text": [{"text": ["name"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["Whether or not the new group should be ordered.  See\n        ", {"text": "", "value": "/hom/hou/PrimGroup", "fallback_text": "hou.PrimGroup", "fullpath": "/hom/hou/PrimGroup", "scheme": "Hom", "type": "link"}, " for more information about ordered groups."]}], "indent": 4, "type": "dt", "text": [{"text": ["is_ordered"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Use ", {"fragment": "#destroy", "text": "", "value": "/hom/hou/PrimGroup#destroy", "fallback_text": "hou.PrimGroup.destroy", "fullpath": "/hom/hou/PrimGroup#destroy", "scheme": "Hom", "type": "link"}, " to remove a primitive group from the\n    geometry."]}], "indent": 0, "text": [{"text": ["createPrimGroup(self, name, is_ordered=False)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/Hou/PrimGroup", "fallback_text": "Hou.PrimGroup", "fullpath": "/hom/Hou/PrimGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createPrimGroup"}, "type": "methods_item", "id": "createPrimGroup"}, {"body": [], "indent": 0, "text": [{"text": ["findPrimGroups(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/PrimGroup", "fallback_text": "hou.PrimGroup", "fullpath": "/hom/hou/PrimGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::findPrimGroups", "replaces": "/expressions/primgroupmask"}, "type": "methods_item", "id": "findPrimGroups"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the edge group.  "]}], "indent": 4, "type": "dt", "text": [{"text": ["name"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Return the edge group with the given name, or ", {"text": ["None"], "type": "code"}, " if no such group\n    exists."]}], "indent": 0, "text": [{"text": ["findEdgeGroup(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/EdgeGroup", "fallback_text": "hou.EdgeGroup", "fullpath": "/hom/hou/EdgeGroup", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findEdgeGroup"}, "type": "methods_item", "id": "findEdgeGroup"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the edge groups in the geometry.    "]}], "indent": 0, "text": [{"text": ["edgeGroups(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/EdgeGroup", "fallback_text": "hou.EdgeGroup", "fullpath": "/hom/hou/EdgeGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::edgeGroups    "}, "type": "methods_item", "id": "edgeGroups"}, {"body": [{"indent": 4, "type": "para", "text": ["Create a new edge group in this geometry."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the new group.  Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if a\n        group with this name already exists.    "]}], "indent": 4, "type": "dt", "text": [{"text": ["name"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Use ", {"fragment": "#destroy", "text": "", "value": "/hom/hou/EdgeGroup#destroy", "fallback_text": "hou.EdgeGroup.destroy", "fullpath": "/hom/hou/EdgeGroup#destroy", "scheme": "Hom", "type": "link"}, " to remove an edge group from the\n    geometry."]}], "indent": 0, "text": [{"text": ["createEdgeGroup(self, name)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/EdgeGroup", "fallback_text": "hou.EdgeGroup", "fullpath": "/hom/hou/EdgeGroup", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::createEdgeGroup"}, "type": "methods_item", "id": "createEdgeGroup"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Groups"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return another Geometry object that is not linked to a particular SOP."]}, {"indent": 4, "type": "para", "text": ["Normally, when you call ", {"fragment": "#geometry", "text": "", "value": "/hom/hou/SopNode#geometry", "fallback_text": "hou.SopNode.geometry", "fullpath": "/hom/hou/SopNode#geometry", "scheme": "Hom", "type": "link"}, ", the resultant Geometry\n    object retains a reference to that SOP, and is said to be unfrozen.  Each\n    time you access points, primitives, attributes, etc. in an unfrozen\n    Geometry object, Houdini uses the SOP\u2019s latest cooked geometry.  So, if you\n    change parameters or change the time for an animated SOP, the Geometry\n    object will update to the SOP\u2019s new geometry."]}, {"indent": 4, "type": "para", "text": ["Unless Python SOPs are involved, a frozen Geometry object does not have a\n    similar live association with a particular SOP.  If you ask a SOP for its\n    geometry and then store a frozen copy of that geometry, when the SOP\n    recooks the frozen Geometry object will not update.  Instead, the frozen\n    geometry saves its own copy of the point and primitive data, and is\n    unaffected by subsequent changes to the SOP.  When a frozen Geometry object\n    is destroyed, any geometry copy it created is also destroyed."]}, {"indent": 4, "type": "para", "text": ["Note that accessing a Geometry object\u2019s points, primitives, attributes,\n    etc. may be faster when dealing with frozen objects.  You may want to work\n    with frozen Geometry in speed-sensitive operations."]}, {"indent": 4, "type": "para", "text": ["Calling this method on an unfrozen Geometry object returns a frozen\n    one.  Calling it on a frozen object has no effect, and it returns\n    a frozen object."]}, {"indent": 4, "type": "para", "text": ["When a Python-defined SOP cooks and runs Python code that asks for the\n    SOP\u2019s geometry, the returned Geometry object is writable.  Modifying this\n    Geometry object affects the output of this SOP.  For efficiency, this\n    geometry object is already frozen, so calling freeze on it has no effect."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If True, the resulting frozen geometry will be read-only.  Use\n        read-only frozen geometry to share embedded geometry among multiple\n        packed primitives."]}], "indent": 4, "type": "dt", "text": ["read_only"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["freeze(self, read_only=False)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Geometry", "fallback_text": "hou.Geometry", "fullpath": "/hom/hou/Geometry", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::freeze"}, "type": "methods_item", "id": "freeze"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Freezing"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["If the Geometry is not frozen, return the ", {"text": "", "value": "/hom/hou/SopNode", "fallback_text": "hou.SopNode", "fullpath": "/hom/hou/SopNode", "scheme": "Hom", "type": "link"}, " object\n    corresponding to this Geometry.  Otherwise, return None."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#freeze", "text": "", "value": "/hom/hou/Geometry#freeze", "fallback_text": "hou.Geometry.freeze", "fullpath": "/hom/hou/Geometry#freeze", "scheme": "Hom", "type": "link"}, " for more information on frozen geometry."]}], "indent": 0, "text": [{"text": ["sopNode(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/SopNode", "fallback_text": "hou.SopNode", "fullpath": "/hom/hou/SopNode", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::sopNode"}, "type": "methods_item", "id": "sopNode"}, {"body": [{"indent": 4, "type": "para", "text": ["If the Geometry is not frozen, return the index of the SOP node output that\n    this geometry corresponds to.  Otherwise, return -1."]}, {"indent": 4, "type": "para", "text": ["For most cases this method will return 0 to indicate that the geometry\n    corresponds to the first output.  This method will only return a value\n    other than 0 for SOP nodes that have multiple outputs."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#freeze", "text": "", "value": "/hom/hou/Geometry#freeze", "fallback_text": "hou.Geometry.freeze", "fullpath": "/hom/hou/Geometry#freeze", "scheme": "Hom", "type": "link"}, " for more information on frozen geometry."]}], "indent": 0, "text": [{"text": ["sopNodeOutputIndex(self)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::sopNodeOutputIndex"}, "type": "methods_item", "id": "sopNodeOutputIndex"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Nodes"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the points in the geometry."]}, {"indent": 4, "type": "para", "text": ["See also the ", {"fragment": "#iterPoints", "text": "", "value": "/hom/hou/Geometry#iterPoints", "fallback_text": "hou.Geometry.iterPoints", "fullpath": "/hom/hou/Geometry#iterPoints", "scheme": "Hom", "type": "link"}, " method."]}], "indent": 0, "text": [{"text": ["points(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::points"}, "type": "methods_item", "id": "points"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a generator that iterates through all the points in the geometry."]}, {"indent": 4, "type": "para", "text": ["Whereas ", {"fragment": "#points", "text": "", "value": "/hom/hou/Geometry#points", "fallback_text": "hou.Geometry.points", "fullpath": "/hom/hou/Geometry#points", "scheme": "Hom", "type": "link"}, " allocates and returns a tuple of all the\n    points in the geometry, this method returns a generator object that will\n    allocate ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " objects on demand.  This object is very fast at\n    random access into the sequence."]}, {"indent": 4, "type": "para", "text": ["If you're accessing a specific point by index and the geometry contains many\n    points, it is faster to use iterPoints() than points().  If, however, you\n    are iterating over all the points in the geometry, it is generally faster\n    to use points() than iterPoints()."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # This is preferred:\n    geo.iterPoints()[23]\n    \n    # over this:\n    geo.points()[23]\n    \n    # But this is preferred:\n    for point in geo.points():\n        ...process point...\n    \n    # over this:\n    for point in geo.iterPoints():\n        ...process point...\n    "]}], "indent": 0, "text": [{"text": ["iterPoints(self)"], "type": "code"}, "  \u2192 generator of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::iterPoints", "replaces": "/expressions/haspoint /expressions/point /expressions/points /expressions/pointlist /expressions/poppoint"}, "type": "methods_item", "id": "iterPoints"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of points corresponding to a pattern of point numbers."]}, {"indent": 4, "type": "para", "text": ["The pattern format is the same one used by the group fields on SOP\n    nodes that take point selections.  Elements in the pattern are separated\n    by spaces, and elements can be point numbers, point number ranges,\n    or group names."]}, {"indent": 4, "type": "para", "text": ["This method can be useful when writing a Python SOP that works on only\n    a selected set of points."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the pattern is not valid or if it\n    refers to a group that does not exist.  Note that an empty pattern is\n    considered to be invalid.  Numbers that do not refer to valid points are\n    not errors, and simply do not match points."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # Return a tuple containing points 5 and 7.\n    geo.globPoints(\"5 7\")\n\n    # Return a tuple containing points 5 to 10.\n    geo.globPoints(\"5-10\")\n\n    # Return a tuple containing all the points in the pointgroup called group1.\n    geo.globPoints(\"group1\")\n\n    # Return all the points except those from 0 to 98.\n    geo.globPoints(\"!0-98\")\n\n    # Return points 5, 10 to 20, and those in group1.\n    geo.globPoints(\"5 group1 10-20\")\n    "]}, {"indent": 4, "type": "para", "text": ["The following Python SOP example is behaves similarly to the\n    ", {"text": ["Point sop"], "fullpath": "/nodes/sop/point", "scheme": "Node", "type": "link", "value": "/nodes/sop/point"}, "."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # This code will work from inside a Python SOP, but not from the Python\n    # shell.  It assumes the Python sop has the following parm tuples:\n    #     group: A string containing which points to affect\n    #     t:     A set of 3 floats that behaves like the point sop's position\n    #            parameter.  Set these parameters to the expressions ($TX, $TY, $TZ).\n    geo = hou.pwd().geometry()\n\n    # Use the group field to determine which points to affect.  If it's blank,\n    # operate on all points.\n    pattern = hou.ch(\"group\")\n    if pattern == \"\":\n        points = geo.points()\n    else:\n        points = geo.globPoints(pattern)\n\n    # Loop through the points, setting the SOP's current point as we go.\n    # Then evaluate the t parm tuple, so it can use the current point (e.g.\n    # with hscript's $TX or Python's pwd().curPoint()).\n    for point in points:\n        hou.pwd().setCurPoint(point)\n        new_position = hou.pwd().evalParmTuple(\"t\")\n        point.setPosition(new_position)\n    "]}], "indent": 0, "text": [{"text": ["globPoints(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::globPoints", "replaces": "/expressions/pointpattern"}, "type": "methods_item", "id": "globPoints"}, {"body": [], "indent": 0, "text": [{"text": ["findClosestPoint(self, pos3)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::findClosestPoint", "replaces": "/expressions/nearpoint"}, "type": "methods_item", "id": "findClosestPoint"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of floats containing one attribute\u2019s values for all the\n    points."]}, {"indent": 4, "type": "para", "text": ["This method only works on int or float attributes.  If the attribute\n    contains more than one element, each point will correspond to multiple\n    values in the result.  For example, if \"Cd\" is a float attribute of size 3\n    and there are 3 points with values (0.1, 0.2, 0.3), (0.5, 0.5, 0.5), and\n    (0.8, 0.7, 0.6) then the result will be (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8,\n    0.7, 0.6)."]}, {"indent": 4, "type": "para", "text": ["Calling this method is faster than looping over all the points and calling\n    ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Point#attribValue", "fallback_text": "hou.Point.attribValue", "fullpath": "/hom/hou/Point#attribValue", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["If the attribute name is invalid or the attribute is not an int or float\n    (e.g. it\u2019s a string attribute), this method raises\n    ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that you cannot pass a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object to this method like\n    you can with many methods dealing with attributes.  However, you can use\n    ", {"fragment": "#name", "text": "", "value": "/hom/hou/Attrib#name", "fallback_text": "hou.Attrib.name", "fullpath": "/hom/hou/Attrib#name", "scheme": "Hom", "type": "link"}, " to easily get the name from an Attrib object."]}], "indent": 0, "text": [{"text": ["pointFloatAttribValues(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["float"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointFloatAttribValues"}, "type": "methods_item", "id": "pointFloatAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a string representation of the floats of one attribute\u2019s value\n    for all the points.  This method is faster than\n    ", {"fragment": "#pointFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#pointFloatAttribValues", "fallback_text": "hou.Geometry.pointFloatAttribValues", "fullpath": "/hom/hou/Geometry#pointFloatAttribValues", "scheme": "Hom", "type": "link"}, ", and you can use the ", {"text": ["array"], "type": "code"}, "\n    module to convert the string into a Python sequence."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/numericType", "fallback_text": "hou.numericType", "fullpath": "/hom/hou/numericType", "scheme": "Hom", "type": "link"}, " value to specify the float data type (either\n        Float16, Float32 or Float64)."]}], "indent": 4, "type": "dt", "text": ["float_type"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["This method provides a faster implementation of the following:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def pointFloatAttribValuesAsString(self, name):\n        return array.array(\"f\", self.pointFloatAttribValues(name)).tostring()\n    "]}, {"indent": 4, "type": "para", "text": ["You can convert the return value from this method to an array using the\n    following method:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def pointFloatAttribValuesAsArray(geometry, name):\n        a = array.array(\"f\")\n        a.fromstring(geometry.pointFloatAttribValuesAsString(name))\n        return a\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#pointFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#pointFloatAttribValues", "fallback_text": "hou.Geometry.pointFloatAttribValues", "fullpath": "/hom/hou/Geometry#pointFloatAttribValues", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["pointFloatAttribValuesAsString(self, name, float_type=hou.numericType.Float32)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointFloatAttribValuesAsString"}, "type": "methods_item", "id": "pointFloatAttribValuesAsString"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all points.\n    You would typically call this method from the code of a Python-defined\n    SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the point attribute."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of int or float values in the same format as that returned\n        by ", {"fragment": "#pointFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#pointFloatAttribValues", "fallback_text": "hou.Geometry.pointFloatAttribValues", "fullpath": "/hom/hou/Geometry#pointFloatAttribValues", "scheme": "Hom", "type": "link"}, ".  See that method for\n        more information."]}], "indent": 4, "type": "dt", "text": ["values"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the attribute name is not valid, the\n    attribute is not an int or float (i.e. it\u2019s a string), or the array of\n    values is not the correct size."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["Also see ", {"fragment": "#pointFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#pointFloatAttribValues", "fallback_text": "hou.Geometry.pointFloatAttribValues", "fullpath": "/hom/hou/Geometry#pointFloatAttribValues", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["setPointFloatAttribValues(self, name, values)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setPointFloatAttribValues"}, "type": "methods_item", "id": "setPointFloatAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all points from\n    a string representation of a sequence of the specified float_type values.\n    This method is faster than ", {"fragment": "#setPointFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#setPointFloatAttribValues", "fallback_text": "hou.Geometry.setPointFloatAttribValues", "fullpath": "/hom/hou/Geometry#setPointFloatAttribValues", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that this method can accept more types that just a string: it can\n    receive any Python object that supports the buffer interface.  In\n    particular, arrays from the ", {"text": ["array"], "type": "code"}, " and ", {"text": ["numpy"], "type": "code"}, " Python modules are\n    supported, so there is no need to first construct strings from those\n    arrays."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/numericType", "fallback_text": "hou.numericType", "fullpath": "/hom/hou/numericType", "scheme": "Hom", "type": "link"}, " value to specify the float data type (either\n        Float16, Float32 or Float64)."]}], "indent": 4, "type": "dt", "text": ["float_type"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the length of the string is not\n    ", {"text": ["len(self.iterPoints() * byte_size_of_float_type)"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#setPointFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#setPointFloatAttribValues", "fallback_text": "hou.Geometry.setPointFloatAttribValues", "fullpath": "/hom/hou/Geometry#setPointFloatAttribValues", "scheme": "Hom", "type": "link"}, " and\n    ", {"fragment": "#pointFloatAttribValuesAsString", "text": "", "value": "/hom/hou/Geometry#pointFloatAttribValuesAsString", "fallback_text": "hou.Geometry.pointFloatAttribValuesAsString", "fullpath": "/hom/hou/Geometry#pointFloatAttribValuesAsString", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["The following example function accepts an ", {"text": ["array.array(\"f\")"], "type": "code"}, " and sets\n    the attribute values to its contents:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def setPointFloatAttribValuesFromArray(geometry, arr):\n        assert(arr.typecode == \"f\")\n        geometry.setPointFloatAttribValuesFromString(arr))\n    "]}], "indent": 0, "text": [{"text": ["setPointFloatAttribValuesFromString(self, name, values, float_type=hou.numericType.Float32)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Volume::setPointFloatAttribValueFromString"}, "type": "methods_item", "id": "setPointFloatAttribValuesFromString"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of integers containing one attribute\u2019s values for all the\n    points."]}, {"indent": 4, "type": "para", "text": ["This method only works on int or float attributes.  If the attribute\n    contains more than one element, each point will correspond to multiple\n    values in the result.  For example, if \"idmap\" is an integer attribute of\n    size 2 and there are 3 points with values (1, 2), (2, 3), and (3, 4)\n    then the result will be (1, 2, 2, 3, 3, 4)."]}, {"indent": 4, "type": "para", "text": ["Calling this method is faster than looping over all the points and calling\n    ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Point#attribValue", "fallback_text": "hou.Point.attribValue", "fullpath": "/hom/hou/Point#attribValue", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["If the attribute name is invalid or the attribute is not an int or float\n    (e.g. it\u2019s a string attribute), this method raises\n    ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that you cannot pass a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object to this method like\n    you can with many methods dealing with attributes.  However, you can use\n    ", {"fragment": "#name", "text": "", "value": "/hom/hou/Attrib#name", "fallback_text": "hou.Attrib.name", "fullpath": "/hom/hou/Attrib#name", "scheme": "Hom", "type": "link"}, " to easily get the name from an Attrib object."]}], "indent": 0, "text": [{"text": ["pointIntAttribValues(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointIntAttribValues"}, "type": "methods_item", "id": "pointIntAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a string representation of the integers of one attribute\u2019s value\n    for all the points.  This method is faster than\n    ", {"fragment": "#pointIntAttribValues", "text": "", "value": "/hom/hou/Geometry#pointIntAttribValues", "fallback_text": "hou.Geometry.pointIntAttribValues", "fullpath": "/hom/hou/Geometry#pointIntAttribValues", "scheme": "Hom", "type": "link"}, ", and you can use the ", {"text": ["array"], "type": "code"}, "\n    module to convert the string into a Python sequence."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/numericType", "fallback_text": "hou.numericType", "fullpath": "/hom/hou/numericType", "scheme": "Hom", "type": "link"}, " value to specify the integer data type (either\n        Int8, Int16, Int32 or Int64)."]}], "indent": 4, "type": "dt", "text": ["int_type"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["This method provides a faster implementation of the following:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def pointIntAttribValuesAsString(self, name):\n        return array.array(\"i\", self.pointIntAttribValues(name)).tostring()\n    "]}, {"indent": 4, "type": "para", "text": ["You can convert the return value from this method to an array using the\n    following method:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def pointIntAttribValuesAsArray(geometry, name):\n        a = array.array(\"i\")\n        a.fromstring(geometry.pointIntAttribValuesAsString(name))\n        return a\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#pointIntAttribValues", "text": "", "value": "/hom/hou/Geometry#pointIntAttribValues", "fallback_text": "hou.Geometry.pointIntAttribValues", "fullpath": "/hom/hou/Geometry#pointIntAttribValues", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["pointIntAttribValuesAsString(self, name, int_type=hou.numericType.Int32)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointIntAttribValuesAsString"}, "type": "methods_item", "id": "pointIntAttribValuesAsString"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all points.\n    You would typically call this method from the code of a Python-defined\n    SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the point attribute."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of int or float values in the same format as that returned\n        by ", {"fragment": "#pointIntAttribValues", "text": "", "value": "/hom/hou/Geometry#pointIntAttribValues", "fallback_text": "hou.Geometry.pointIntAttribValues", "fullpath": "/hom/hou/Geometry#pointIntAttribValues", "scheme": "Hom", "type": "link"}, ".  See that method for\n        more information."]}], "indent": 4, "type": "dt", "text": ["values"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the attribute name is not valid, the\n    attribute is not an int or float (i.e. it\u2019s a string), or the array of\n    values is not the correct size."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["Also see ", {"fragment": "#pointIntAttribValues", "text": "", "value": "/hom/hou/Geometry#pointIntAttribValues", "fallback_text": "hou.Geometry.pointIntAttribValues", "fullpath": "/hom/hou/Geometry#pointIntAttribValues", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["setPointIntAttribValues(self, name, values)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setPointIntAttribValues"}, "type": "methods_item", "id": "setPointIntAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all points from\n    a string representation of a sequence of the specified int_type values.\n    This method is faster than ", {"fragment": "#setPointIntAttribValues", "text": "", "value": "/hom/hou/Geometry#setPointIntAttribValues", "fallback_text": "hou.Geometry.setPointIntAttribValues", "fullpath": "/hom/hou/Geometry#setPointIntAttribValues", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that this method can accept more types that just a string: it can\n    receive any Python object that supports the buffer interface.  In\n    particular, arrays from the ", {"text": ["array"], "type": "code"}, " and ", {"text": ["numpy"], "type": "code"}, " Python modules are\n    supported, so there is no need to first construct strings from those\n    arrays."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/numericType", "fallback_text": "hou.numericType", "fullpath": "/hom/hou/numericType", "scheme": "Hom", "type": "link"}, " value to specify the integer data type (either\n        Int8, Int16, Int32 or Int64)."]}], "indent": 4, "type": "dt", "text": ["int_type"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the length of the string is not\n    ", {"text": ["len(self.iterPoints() * byte_size_of_int_type)"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#setPointIntAttribValues", "text": "", "value": "/hom/hou/Geometry#setPointIntAttribValues", "fallback_text": "hou.Geometry.setPointIntAttribValues", "fullpath": "/hom/hou/Geometry#setPointIntAttribValues", "scheme": "Hom", "type": "link"}, " and\n    ", {"fragment": "#pointIntAttribValuesAsString", "text": "", "value": "/hom/hou/Geometry#pointIntAttribValuesAsString", "fallback_text": "hou.Geometry.pointIntAttribValuesAsString", "fullpath": "/hom/hou/Geometry#pointIntAttribValuesAsString", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["The following example function accepts an ", {"text": ["array.array(\"i\")"], "type": "code"}, " and sets\n    the attribute values to its contents, assuming sizeof(signed int) == 4:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def setPointIntAttribValuesFromArray(geometry, arr):\n        assert(arr.typecode == \"i\")\n        geometry.setPointIntAttribValuesFromString(arr))\n    "]}], "indent": 0, "text": [{"text": ["setPointIntAttribValuesFromString(self, name, values, int_type=hou.numericType.Int32)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Volume::setPointIntAttribValueFromString"}, "type": "methods_item", "id": "setPointIntAttribValuesFromString"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of strings containing one attribute\u2019s values for all the\n    points."]}, {"indent": 4, "type": "para", "text": ["This method only works on string attributes.  If the attribute\n    contains more than one element, each point will correspond to multiple\n    values in the result.  For example, if \"strmap\" is a string attribute of\n    size 2 and there are 3 points with values (\"apple\", \"orange\"), \n    (\"red\", \"blue\"), and (\"one\", \"two\")\n    then the result will be (\"apple\", \"orange\", \"red\", \"blue\", \"one\", \"two\")."]}, {"indent": 4, "type": "para", "text": ["Calling this method is faster than looping over all the points and calling\n    ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Point#attribValue", "fallback_text": "hou.Point.attribValue", "fullpath": "/hom/hou/Point#attribValue", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["If the attribute name is invalid or the attribute is not a string attribute\n    then this method raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that you cannot pass a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object to this method like\n    you can with many methods dealing with attributes.  However, you can use\n    ", {"fragment": "#name", "text": "", "value": "/hom/hou/Attrib#name", "fallback_text": "hou.Attrib.name", "fullpath": "/hom/hou/Attrib#name", "scheme": "Hom", "type": "link"}, " to easily get the name from an Attrib object."]}], "indent": 0, "text": [{"text": ["pointStringAttribValues(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointStringAttribValues"}, "type": "methods_item", "id": "pointStringAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all points.\n    You would typically call this method from the code of a Python-defined\n    SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the point attribute."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of string values in the same format as that returned\n        by ", {"fragment": "#pointStringAttribValues", "text": "", "value": "/hom/hou/Geometry#pointStringAttribValues", "fallback_text": "hou.Geometry.pointStringAttribValues", "fullpath": "/hom/hou/Geometry#pointStringAttribValues", "scheme": "Hom", "type": "link"}, ".  See that method for\n        more information."]}], "indent": 4, "type": "dt", "text": ["values"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the attribute name is not valid, the\n    attribute is not a string, or the array of values is not the correct size."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["Also see ", {"fragment": "#pointStringAttribValues", "text": "", "value": "/hom/hou/Geometry#pointStringAttribValues", "fallback_text": "hou.Geometry.pointStringAttribValues", "fullpath": "/hom/hou/Geometry#pointStringAttribValues", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["setPointStringAttribValues(self, name, values)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setPointStringAttribValues"}, "type": "methods_item", "id": "setPointStringAttribValues"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Points"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["The first point that makes up the edge.  See ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 4, "type": "dt", "text": [{"text": ["p0"], "type": "code"}]}, {"body": [{"indent": 8, "type": "para", "text": ["The second point that makes up the edge.  See ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 4, "type": "dt", "text": [{"text": ["p1"], "type": "code"}]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["finds an edge given two points, or ", {"text": ["None"], "type": "code"}, " if no such edge exists"]}], "indent": 0, "text": [{"text": ["findEdge(self, p0, p1)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Edge", "fallback_text": "hou.Edge", "fullpath": "/hom/hou/Edge", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::findEdge "}, "type": "methods_item", "id": "findEdge"}, {"body": [], "indent": 0, "text": [{"text": ["findClosestPrim(self, pos3)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::findClosestPrim", "replaces": "/expressions/xyzdist"}, "type": "methods_item", "id": "findClosestPrim"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of edges corresponding to an edge pattern."]}, {"indent": 4, "type": "para", "text": ["The pattern format is the same one used by the group fields on SOP nodes\n    that take edge selections.  See ", {"fragment": "#globPoints", "text": "", "value": "/hom/hou/Geometry#globPoints", "fallback_text": "hou.Geometry.globPoints", "fullpath": "/hom/hou/Geometry#globPoints", "scheme": "Hom", "type": "link"}, " for\n    more information."]}], "indent": 0, "text": [{"text": ["globEdges(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Edge", "fallback_text": "hou.Edge", "fullpath": "/hom/hou/Edge", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::globPrims"}, "type": "methods_item", "id": "globEdges"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Edges"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Given a sequence of three floats containing a position, find the location\n    on the primitive closest to that position and return a tuple containing\n    that primitive, the u value on the primitive, the v value on the primitive,\n    and the distance to the primitive."]}, {"indent": 4, "type": "para", "text": ["Note that the first value in the return tuple can be None if there are\n    no primitives in the geometry."]}], "indent": 0, "text": [{"text": ["nearestPrim(self, position)"], "type": "code"}, "  \u2192 (", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ")"], "role": "item", "attrs": {"cppname": "HOM_Geometry::nearestPrim", "replaces": "/expressions/xyzdist"}, "type": "methods_item", "id": "nearestPrim"}, {"body": [], "indent": 0, "text": [{"text": ["findParticleById(self, particle_id)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " or ", {"text": ["None"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::findParticleById", "replaces": "/expressions/poppointid /expressions/poppointnum"}, "type": "methods_item", "id": "findParticleById"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of all the primitives in the geometry.  The primitives\n    returned will be subclasses of ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, " (e.g.polygons, volumes,\n    etc.)."]}, {"indent": 4, "type": "para", "text": ["See also:"]}, {"body": [{"indent": 4, "blevel": 6, "type": "bullet", "text": [{"fragment": "#iterPrims", "text": "", "value": "/hom/hou/Geometry#iterPrims", "fallback_text": "hou.Geometry.iterPrims", "fullpath": "/hom/hou/Geometry#iterPrims", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"text": "", "value": "/hom/hou/Face", "fallback_text": "hou.Face", "fullpath": "/hom/hou/Face", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"text": "", "value": "/hom/hou/Polygon", "fallback_text": "hou.Polygon", "fullpath": "/hom/hou/Polygon", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"text": "", "value": "/hom/hou/Surface", "fallback_text": "hou.Surface", "fullpath": "/hom/hou/Surface", "scheme": "Hom", "type": "link"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "text": [{"text": "", "value": "/hom/hou/Volume", "fallback_text": "hou.Volume", "fullpath": "/hom/hou/Volume", "scheme": "Hom", "type": "link"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["prims(self)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::prims", "replaces": "/expressions/hasprim /expressions/prim /expressions/prims /expressions/primlist"}, "type": "methods_item", "id": "prims"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a generator that iterates through all the primitives in the\n    geometry."]}, {"indent": 4, "type": "para", "text": ["Whereas ", {"fragment": "#prims", "text": "", "value": "/hom/hou/Geometry#prims", "fallback_text": "hou.Geometry.prims", "fullpath": "/hom/hou/Geometry#prims", "scheme": "Hom", "type": "link"}, " allocates and returns a tuple of all the\n    primitives in the geometry, this method returns a generator object that\n    will yield ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, " objects on demand.  This object is very fast at\n    random access into the sequence."]}, {"indent": 4, "type": "para", "text": ["If you're accessing a specific primitive by index and the geometry contains\n    many primitives, it is faster to use ", {"text": ["iterPrims()"], "type": "code"}, " than ", {"text": ["prims()"], "type": "code"}, ".  If, however,\n    you are iterating over all the primitives in the geometry, it is generally\n    faster to use ", {"text": ["prims()"], "type": "code"}, " than ", {"text": ["iterPrims()"], "type": "code"}, "."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    # This is preferred:\n    geo.iterPrims()[23]\n    \n    # over this:\n    geo.prims()[23]\n    \n    # But this is preferred:\n    for prim in geo.prims():\n        ...process prim...\n    \n    # over this:\n    for prim in geo.iterPrims():\n        ...process prim...\n    "]}, {"indent": 4, "type": "para", "text": ["See also the ", {"fragment": "#prims", "text": "", "value": "/hom/hou/Geometry#prims", "fallback_text": "hou.Geometry.prims", "fullpath": "/hom/hou/Geometry#prims", "scheme": "Hom", "type": "link"}, " method."]}], "indent": 0, "text": [{"text": ["iterPrims(self)"], "type": "code"}, "  \u2192 generator of ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::iterPrims"}, "type": "methods_item", "id": "iterPrims"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of primitives corresponding to a pattern of primitive\n    numbers."]}, {"indent": 4, "type": "para", "text": ["The pattern format is the same one used by the group fields on SOP nodes\n    that take primitive selections.  See ", {"fragment": "#globPoints", "text": "", "value": "/hom/hou/Geometry#globPoints", "fallback_text": "hou.Geometry.globPoints", "fullpath": "/hom/hou/Geometry#globPoints", "scheme": "Hom", "type": "link"}, " for\n    more information."]}], "indent": 0, "text": [{"text": ["globPrims(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::globPrims"}, "type": "methods_item", "id": "globPrims"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns whether the geometry contains at least one primitive of the\n    specified type."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A string containing the name of a primitive type.\n        Typical examples are ", {"text": ["\"Poly\""], "type": "code"}, " (polygon) or ", {"text": ["\"PackedAgent\""], "type": "code"}, " (agent\n        packed primitive)."]}, {"indent": 8, "type": "para", "text": ["To see a complete list of possible ", {"text": ["typename"], "type": "code"}, " values, run ", {"text": ["ginfo -P"], "type": "code"}, " on\n        a Houdini tools command line."]}], "indent": 4, "type": "dt", "text": [{"text": ["typename"], "type": "code"}]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["containsPrimType(self, typename)"], "type": "code"}, "  \u2192 ", {"text": ["bool"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::containsPrimType"}, "type": "methods_item", "id": "containsPrimType"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns the number of primitives of the specified type in the geometry."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A string containing the name of a primitive type.\n        Typical examples are ", {"text": ["\"Poly\""], "type": "code"}, " (polygon) or ", {"text": ["\"PackedAgent\""], "type": "code"}, " (agent\n        packed primitive)."]}, {"indent": 8, "type": "para", "text": ["To see a complete list of possible ", {"text": ["typename"], "type": "code"}, " values, run ", {"text": ["ginfo -P"], "type": "code"}, " on\n        a Houdini tools command line."]}], "indent": 4, "type": "dt", "text": [{"text": ["typename"], "type": "code"}]}], "container": true, "type": "dt_group"}], "indent": 0, "text": [{"text": ["countPrimType(self, typename)"], "type": "code"}, "  \u2192 ", {"text": ["long"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::countPrimType"}, "type": "methods_item", "id": "countPrimType"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of floats containing one attribute\u2019s values for all the\n    primitives."]}, {"indent": 4, "type": "para", "text": ["This method only works on int or float attributes.  If the attribute\n    contains more than one element, each primitive will correspond to multiple\n    values in the result.  For example, if ", {"text": ["Cd"], "type": "code"}, " is a float attribute of size 3\n    and there are 3 primitives with values (0.1, 0.2, 0.3), (0.5, 0.5, 0.5), and\n    (0.8, 0.7, 0.6) then the result will be (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8,\n    0.7, 0.6)."]}, {"indent": 4, "type": "para", "text": ["Calling this method is faster than looping over all the primitives and\n    calling ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Prim#attribValue", "fallback_text": "hou.Prim.attribValue", "fullpath": "/hom/hou/Prim#attribValue", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["If the attribute name is invalid or the attribute is not an int or float\n    (e.g. it\u2019s a string attribute), this method raises\n    ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that you cannot pass a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object to this method like\n    you can with many methods dealing with attributes.  However, you can use\n    ", {"fragment": "#name", "text": "", "value": "/hom/hou/Attrib#name", "fallback_text": "hou.Attrib.name", "fullpath": "/hom/hou/Attrib#name", "scheme": "Hom", "type": "link"}, " to easily get the name from an Attrib object."]}], "indent": 0, "text": [{"text": ["primFloatAttribValues(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["float"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primFloatAttribValues"}, "type": "methods_item", "id": "primFloatAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a string representation of the floats of one attribute\u2019s value\n    for all the primitives.  This method is faster than\n    ", {"fragment": "#primFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#primFloatAttribValues", "fallback_text": "hou.Geometry.primFloatAttribValues", "fullpath": "/hom/hou/Geometry#primFloatAttribValues", "scheme": "Hom", "type": "link"}, ", and you can use the ", {"text": ["array"], "type": "code"}, "\n    module to convert the string into a Python sequence."]}, {"indent": 4, "type": "para", "text": ["This method provides a faster implementation of the following:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def primFloatAttribValuesAsString(self, name):\n        return array.array(\"f\", self.primFloatAttribValues(name)).tostring()\n    "]}, {"indent": 4, "type": "para", "text": ["You can convert the return value from this method to an array using the\n    following method:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def primFloatAttribValuesAsArray(geometry, name):\n        a = array.array(\"f\")\n        a.fromstring(geometry.primFloatAttribValuesAsString(name))\n        return a\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#primFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#primFloatAttribValues", "fallback_text": "hou.Geometry.primFloatAttribValues", "fullpath": "/hom/hou/Geometry#primFloatAttribValues", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["primFloatAttribValuesAsString(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primFloatAttribValuesAsString"}, "type": "methods_item", "id": "primFloatAttribValuesAsString"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all primitives.\n    You would typically call this method from the code of a Python-defined\n    SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the primitive attribute."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of int or float values in the same format as that returned\n        by ", {"fragment": "#primFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#primFloatAttribValues", "fallback_text": "hou.Geometry.primFloatAttribValues", "fullpath": "/hom/hou/Geometry#primFloatAttribValues", "scheme": "Hom", "type": "link"}, ".  See that method for\n        more information."]}], "indent": 4, "type": "dt", "text": ["values"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the attribute name is not valid, the\n    attribute is not an int or float (i.e. it\u2019s a string), or the array of\n    values is not the correct size."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["Also see ", {"fragment": "#primFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#primFloatAttribValues", "fallback_text": "hou.Geometry.primFloatAttribValues", "fullpath": "/hom/hou/Geometry#primFloatAttribValues", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["setPrimFloatAttribValues(self, name, values)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setPrimFloatAttribValues"}, "type": "methods_item", "id": "setPrimFloatAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all primitives\n    from a string representation of a sequence of the specified float_type\n    values.\n    This method is faster than ", {"fragment": "#setPrimFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#setPrimFloatAttribValues", "fallback_text": "hou.Geometry.setPrimFloatAttribValues", "fullpath": "/hom/hou/Geometry#setPrimFloatAttribValues", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that this method can accept more types that just a string: it can\n    receive any Python object that supports the buffer interface.  In\n    particular, arrays from the ", {"text": ["array"], "type": "code"}, " and ", {"text": ["numpy"], "type": "code"}, " Python modules are\n    supported, so there is no need to first construct strings from those\n    arrays."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/numericType", "fallback_text": "hou.numericType", "fullpath": "/hom/hou/numericType", "scheme": "Hom", "type": "link"}, " value to specify the float data type (either\n        Float16, Float32 or Float64)."]}], "indent": 4, "type": "dt", "text": ["float_type"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the length of the string is not\n    ", {"text": ["len(self.iterPrims() * byte_size_of_float_type)"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#setPrimFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#setPrimFloatAttribValues", "fallback_text": "hou.Geometry.setPrimFloatAttribValues", "fullpath": "/hom/hou/Geometry#setPrimFloatAttribValues", "scheme": "Hom", "type": "link"}, " and\n    ", {"fragment": "#primFloatAttribValuesAsString", "text": "", "value": "/hom/hou/Geometry#primFloatAttribValuesAsString", "fallback_text": "hou.Geometry.primFloatAttribValuesAsString", "fullpath": "/hom/hou/Geometry#primFloatAttribValuesAsString", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["The following example function accepts an ", {"text": ["array.array(\"f\")"], "type": "code"}, " and sets\n    the attribute values to its contents:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def setPrimFloatAttribValuesFromArray(geometry, arr):\n        assert(arr.typecode == \"f\")\n        geometry.setPrimFloatAttribValuesFromString(arr)\n    "]}], "indent": 0, "text": [{"text": ["setPrimFloatAttribValuesFromString(self, name, values, float_type=hou.numericType.Float32)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Volume::setPrimFloatAttribValueFromString"}, "type": "methods_item", "id": "setPrimFloatAttribValuesFromString"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of integers containing one attribute\u2019s values for all the\n    primitives."]}, {"indent": 4, "type": "para", "text": ["This method only works on int or float attributes.  If the attribute\n    contains more than one element, each primitive will correspond to multiple\n    values in the result.  For example, if ", {"text": ["idmap"], "type": "code"}, " is an integer attribute of\n    size 2 and there are 3 primitives with values (1, 2), (2, 3), and (3,4)\n    then the result will be (1, 2, 2, 3, 3, 4)."]}, {"indent": 4, "type": "para", "text": ["Calling this method is faster than looping over all the primitives and\n    calling ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Prim#attribValue", "fallback_text": "hou.Prim.attribValue", "fullpath": "/hom/hou/Prim#attribValue", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["If the attribute name is invalid or the attribute is not an int or float\n    (e.g. it\u2019s a string attribute), this method raises\n    ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that you cannot pass a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object to this method like\n    you can with many methods dealing with attributes.  However, you can use\n    ", {"fragment": "#name", "text": "", "value": "/hom/hou/Attrib#name", "fallback_text": "hou.Attrib.name", "fullpath": "/hom/hou/Attrib#name", "scheme": "Hom", "type": "link"}, " to easily get the name from an Attrib object."]}], "indent": 0, "text": [{"text": ["primIntAttribValues(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primIntAttribValues"}, "type": "methods_item", "id": "primIntAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a string representation of the integers of one attribute\u2019s value\n    for all the primitives.  This method is faster than\n    ", {"fragment": "#primFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#primFloatAttribValues", "fallback_text": "hou.Geometry.primFloatAttribValues", "fullpath": "/hom/hou/Geometry#primFloatAttribValues", "scheme": "Hom", "type": "link"}, ", and you can use the ", {"text": ["array"], "type": "code"}, "\n    module to convert the string into a Python sequence."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/numericType", "fallback_text": "hou.numericType", "fullpath": "/hom/hou/numericType", "scheme": "Hom", "type": "link"}, " value to specify the integer data type (either\n        Int8, Int16, Int32 or Int64)."]}], "indent": 4, "type": "dt", "text": ["int_type"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["This method provides a faster implementation of the following:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def primIntAttribValuesAsString(self, name):\n        return array.array(\"i\", self.primIntAttribValues(name)).tostring()\n    "]}, {"indent": 4, "type": "para", "text": ["You can convert the return value from this method to an array using the\n    following method:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import array\n    def primIntAttribValuesAsArray(geometry, name):\n        a = array.array(\"i\")\n        a.fromstring(geometry.primIntAttribValuesAsString(name))\n        return a\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#primIntAttribValues", "text": "", "value": "/hom/hou/Geometry#primIntAttribValues", "fallback_text": "hou.Geometry.primIntAttribValues", "fullpath": "/hom/hou/Geometry#primIntAttribValues", "scheme": "Hom", "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["primIntAttribValuesAsString(self, name, int_type=hou.numericType.Int32)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primIntAttribValuesAsString"}, "type": "methods_item", "id": "primIntAttribValuesAsString"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all primitives.\n    You would typically call this method from the code of a Python-defined\n    SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the primitive attribute."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of int or float values in the same format as that returned\n        by ", {"fragment": "#primFloatAttribValues", "text": "", "value": "/hom/hou/Geometry#primFloatAttribValues", "fallback_text": "hou.Geometry.primFloatAttribValues", "fullpath": "/hom/hou/Geometry#primFloatAttribValues", "scheme": "Hom", "type": "link"}, ".  See that method for\n        more information."]}], "indent": 4, "type": "dt", "text": ["values"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the attribute name is not valid, the\n    attribute is not an int or float (i.e. it\u2019s a string), or the array of\n    values is not the correct size."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["Also see ", {"fragment": "#primIntAttribValues", "text": "", "value": "/hom/hou/Geometry#primIntAttribValues", "fallback_text": "hou.Geometry.primIntAttribValues", "fullpath": "/hom/hou/Geometry#primIntAttribValues", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["setPrimIntAttribValues(self, name, values)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setPrimIntAttribValues"}, "type": "methods_item", "id": "setPrimIntAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all primitives\n    from a string representation of a sequence of the specified int_type\n    values.\n    This method is faster than ", {"fragment": "#setPrimIntAttribValues", "text": "", "value": "/hom/hou/Geometry#setPrimIntAttribValues", "fallback_text": "hou.Geometry.setPrimIntAttribValues", "fullpath": "/hom/hou/Geometry#setPrimIntAttribValues", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that this method can accept more types that just a string: it can\n    receive any Python object that supports the buffer interface.  In\n    particular, arrays from the ", {"text": ["array"], "type": "code"}, " and ", {"text": ["numpy"], "type": "code"}, " Python modules are\n    supported, so there is no need to first construct strings from those\n    arrays."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["A ", {"text": "", "value": "/hom/hou/numericType", "fallback_text": "hou.numericType", "fullpath": "/hom/hou/numericType", "scheme": "Hom", "type": "link"}, " value to specify the integer data type (either\n        Int8, Int16, Int32 or Int64)."]}], "indent": 4, "type": "dt", "text": ["int_type"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the length of the string is not\n    ", {"text": ["len(self.iterPrims() * byte_size_of_int_type)"], "type": "code"}, "."]}, {"indent": 4, "type": "para", "text": ["See ", {"fragment": "#setPrimIntAttribValues", "text": "", "value": "/hom/hou/Geometry#setPrimIntAttribValues", "fallback_text": "hou.Geometry.setPrimIntAttribValues", "fullpath": "/hom/hou/Geometry#setPrimIntAttribValues", "scheme": "Hom", "type": "link"}, " and\n    ", {"fragment": "#primIntAttribValuesAsString", "text": "", "value": "/hom/hou/Geometry#primIntAttribValuesAsString", "fallback_text": "hou.Geometry.primIntAttribValuesAsString", "fullpath": "/hom/hou/Geometry#primIntAttribValuesAsString", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["The following example function accepts an ", {"text": ["array.array(\"i\")"], "type": "code"}, " and sets\n    the attribute values to its contents, assuming sizeof(signed int) == 4:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    def setPrimIntAttribValuesFromArray(geometry, arr):\n        assert(arr.typecode == \"i\")\n        geometry.setPrimIntAttribValuesFromString(arr)\n    "]}], "indent": 0, "text": [{"text": ["setPrimIntAttribValuesFromString(self, name, values, int_type=hou.numericType.Int32)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Volume::setPrimIntAttribValueFromString"}, "type": "methods_item", "id": "setPrimIntAttribValuesFromString"}, {"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of strings containing one attribute\u2019s values for all the\n    primitives."]}, {"indent": 4, "type": "para", "text": ["This method only works on string attributes.  If the attribute\n    contains more than one element, each primitive will correspond to multiple\n    values in the result.  For example, if \"strmap\" is a string attribute of\n    size 2 and there are 3 primitives with values (\"apple\", \"orange\"), \n    (\"red\", \"blue\"), and (\"one\", \"two\")\n    then the result will be (\"apple\", \"orange\", \"red\", \"blue\", \"one\", \"two\")."]}, {"indent": 4, "type": "para", "text": ["Calling this method is faster than looping over all the primitives and\n    calling ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Prim#attribValue", "fallback_text": "hou.Prim.attribValue", "fullpath": "/hom/hou/Prim#attribValue", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["If the attribute name is invalid or the attribute is not a string\n    attribute) then this method raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "type": "para", "text": ["Note that you cannot pass a ", {"text": "", "value": "/hom/hou/Attrib", "fallback_text": "hou.Attrib", "fullpath": "/hom/hou/Attrib", "scheme": "Hom", "type": "link"}, " object to this method like\n    you can with many methods dealing with attributes.  However, you can use\n    ", {"fragment": "#name", "text": "", "value": "/hom/hou/Attrib#name", "fallback_text": "hou.Attrib.name", "fullpath": "/hom/hou/Attrib#name", "scheme": "Hom", "type": "link"}, " to easily get the name from an Attrib object."]}], "indent": 0, "text": [{"text": ["primStringAttribValues(self, name)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primStringAttribValues"}, "type": "methods_item", "id": "primStringAttribValues"}, {"body": [{"indent": 4, "type": "para", "text": ["For a particular attribute, set the attribute values for all primitives.\n    You would typically call this method from the code of a Python-defined\n    SOP."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["The name of the primitive attribute."]}], "indent": 4, "type": "dt", "text": ["name"]}, {"body": [{"indent": 8, "type": "para", "text": ["A sequence of string values in the same format as that returned\n        by ", {"fragment": "#primStringAttribValues", "text": "", "value": "/hom/hou/Geometry#primStringAttribValues", "fallback_text": "hou.Geometry.primStringAttribValues", "fullpath": "/hom/hou/Geometry#primStringAttribValues", "scheme": "Hom", "type": "link"}, ".  See that method for\n        more information."]}], "indent": 4, "type": "dt", "text": ["values"]}], "container": true, "type": "dt_group"}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the attribute name is not valid, the\n    attribute is not a string, or the array of values is not the correct size."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["Also see ", {"fragment": "#primStringAttribValues", "text": "", "value": "/hom/hou/Geometry#primStringAttribValues", "fallback_text": "hou.Geometry.primStringAttribValues", "fullpath": "/hom/hou/Geometry#primStringAttribValues", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["setPrimStringAttribValues(self, name, values)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::setPrimStringAttribValues"}, "type": "methods_item", "id": "setPrimStringAttribValues"}, {"body": [], "indent": 0, "text": [{"text": ["metaballWeight(self, pos3)"], "type": "code"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::metaballWeight", "replaces": "/expressions/metaweight"}, "type": "methods_item", "id": "metaballWeight"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Primitives"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return a tuple of vertices corresponding to a pattern of vertex\n    numbers."]}, {"indent": 4, "type": "para", "text": ["The pattern format is the same one used by the group fields on SOP nodes\n    that take vertex selections.  See ", {"fragment": "#globPoints", "text": "", "value": "/hom/hou/Geometry#globPoints", "fallback_text": "hou.Geometry.globPoints", "fullpath": "/hom/hou/Geometry#globPoints", "scheme": "Hom", "type": "link"}, " for\n    more information."]}], "indent": 0, "text": [{"text": ["globVertices(self, pattern)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Vertex", "fallback_text": "hou.Vertex", "fullpath": "/hom/hou/Vertex", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::globPrims"}, "type": "methods_item", "id": "globVertices"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Vertices"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Return the geometry data in bgeo format."]}, {"indent": 4, "type": "para", "text": ["For example:"]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    geometry = hou.node(\"/obj/geo1/torus1\").geometry()\n    bgeo_data = geometry.data()\n    open(\"/tmp/torus.bgeo\", \"wb\").write(bgeo_data)\n    "]}], "indent": 0, "text": [{"text": ["data(self)"], "type": "code"}, "  \u2192 ", {"text": ["str"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::data"}, "type": "methods_item", "id": "data"}, {"body": [{"indent": 4, "type": "para", "text": ["Save the contents of the geometry object to a file.  The file extension\n    determines what file format to use."]}, {"indent": 4, "type": "para", "text": ["All file formats supported by Houdini (e.g. geo, bgeo, obj, etc.),\n    including extensions listed in ", {"text": ["GEOio"], "type": "code"}, ", are supported.  If the file\n    extension is not recognized, the bgeo format is used."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the path to the file is invalid or\n    there were permission or other I/O errors."]}], "indent": 0, "text": [{"text": ["saveToFile(self, file_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::saveToFile", "replaces": "/commands/opsave"}, "type": "methods_item", "id": "saveToFile"}, {"body": [{"indent": 4, "type": "para", "text": ["Replace the contents of this geometry object with the data stored in a\n    file.  You would typically call this method from the code of a\n    Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["You may specify any type of file supported by Houdini\u2019s File SOP.  See\n    ", {"fragment": "#saveToFile", "text": "", "value": "/hom/hou/Geometry#saveToFile", "fallback_text": "hou.Geometry.saveToFile", "fullpath": "/hom/hou/Geometry#saveToFile", "scheme": "Hom", "type": "link"}, " for more information."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if the file does not exist or otherwise\n    cannot be loaded."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["See also ", {"fragment": "#merge", "text": "", "value": "/hom/hou/Geometry#merge", "fallback_text": "hou.Geometry.merge", "fullpath": "/hom/hou/Geometry#merge", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["loadFromFile(self, file_name)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::loadFromFile"}, "type": "methods_item", "id": "loadFromFile"}, {"body": [{"indent": 4, "type": "para", "text": ["Remove everything from this geometry object.  The geometry will have no\n    points or primitives after calling this method."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}], "indent": 0, "text": [{"text": ["clear(self)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::clear"}, "type": "methods_item", "id": "clear"}, {"body": [{"indent": 4, "type": "para", "text": ["Merge the points and primitives from another ", {"text": "", "value": "/hom/hou/Geometry", "fallback_text": "hou.Geometry", "fullpath": "/hom/hou/Geometry", "scheme": "Hom", "type": "link"}, " object into\n    this one.  The new points and primitives are appended to this geometry\u2019s\n    points and primitives.  You would typically call this method from the code\n    of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}, {"indent": 4, "type": "para", "text": ["See also ", {"fragment": "#loadFromFile", "text": "", "value": "/hom/hou/Geometry#loadFromFile", "fallback_text": "hou.Geometry.loadFromFile", "fullpath": "/hom/hou/Geometry#loadFromFile", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "text": [{"text": ["merge(self, geometry)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::merge"}, "type": "methods_item", "id": "merge"}, {"body": [{"indent": 4, "type": "para", "text": ["Deterimines if a ray (given by it\u2019s origin and direction) intersects the\n    geometry. The intersection point (in world space), the normal, and the \n    parametric coordinates are stored in p, n, uvw respectively. The primitive\n    number of the intersected primitive is returned. A group \n    pattern is optional."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/ObjectWasDeleted", "fallback_text": "hou.ObjectWasDeleted", "fullpath": "/hom/hou/ObjectWasDeleted", "scheme": "Hom", "type": "link"}, " if the SOP is deleted."]}], "indent": 0, "text": [{"text": ["intersect(self, rayorig, dir, p, n, uvw, pattern=nullptr)"], "type": "code"}, "  \u2192 ", {"text": ["int"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::intersect"}, "type": "methods_item", "id": "intersect"}, {"body": [{"indent": 4, "type": "para", "text": ["Invokes verb.execute() with myself as the first input, and returns\n    the resulting geometry.  This allows one to chain a series of\n    verbs invocations: geo.execute(subdivide).execute(subdivide)."]}, {"indent": 4, "type": "para", "text": ["The optional inputs will have the geometry itself prepended."]}], "indent": 0, "text": [{"text": ["execute(self, verb, inputs=[])"], "type": "code"}, "  \u2192 ", {"text": ["HOM_Geometry"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::execute"}, "type": "methods_item", "id": "execute"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Data"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Transforms (e.g. rotates, scales, translates, etc.) the geometry by a\n    transformation matrix.  You would typically call this method from the code\n    of a Python-defined SOP."]}, {"indent": 4, "type": "para", "text": ["See ", {"text": "", "value": "/hom/hou/hmath", "fallback_text": "hou.hmath", "fullpath": "/hom/hou/hmath", "scheme": "Hom", "type": "link"}, " for functions that build transformation matrices."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}], "indent": 0, "text": [{"text": ["transform(self, matrix)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::transform"}, "type": "methods_item", "id": "transform"}, {"body": [{"indent": 4, "type": "para", "text": ["Transforms a set of primitives (e.g. rotates, scales, translates, etc.) by\n    a transformation matrix.  You would typically call this method from the\n    code of a Python-defined SOP."]}, {"lang": "python", "indent": 4, "type": "pre", "text": ["\n    import math\n\n    # This code will work from inside a Python SOP, but not from the Python\n    # shell.\n\n    def createCircle(geo, num_vertices=10):\n        # Create a closed curve with the specified number of vertices.\n        curve = geo.createNURBSCurve(num_vertices)\n        curve.setIsClosed(True)\n\n        # Arrange the points into a unit circle on the XZ plane,\n        # centered about the origin.\n        for i, vertex in enumerate(curve.vertices()):\n            angle = i * (2.0 * math.pi) / num_vertices\n            position = (math.cos(angle), 0, math.sin(angle))\n            vertex.point().setPosition(position)\n        return curve\n\n    # Create a bunch of circles on the XZ plane, tilt them slightly\n    # about X, translate them away from the origin, and rotate each\n    # one about the y axis by a different amount.\n    geo = hou.pwd().geometry()\n    num_copies = 20\n    for i in range(num_copies):\n        curve = createCircle(geo)\n        geo.transformPrims([curve],\n            hou.hmath.buildRotateAboutAxis((1, 0, 0), 30) *\n            hou.hmath.buildTranslate((2, 0, 0)) *\n            hou.hmath.buildRotateAboutAxis((0, 1, 0), i * 360.0 / num_copies))\n    "]}, {"indent": 4, "type": "para", "text": ["See ", {"text": "", "value": "/hom/hou/hmath", "fallback_text": "hou.hmath", "fullpath": "/hom/hou/hmath", "scheme": "Hom", "type": "link"}, " functions that build transformation matrices."]}, {"indent": 4, "type": "para", "text": ["Raises ", {"text": "", "value": "/hom/hou/GeometryPermissionError", "fallback_text": "hou.GeometryPermissionError", "fullpath": "/hom/hou/GeometryPermissionError", "scheme": "Hom", "type": "link"}, " if this geometry is not\n    modifiable."]}], "indent": 0, "text": [{"text": ["transformPrims(self, prims, matrix)"], "type": "code"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::transformPrims"}, "type": "methods_item", "id": "transformPrims"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Transformation"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, " objects that make a path connecting the\n    primitives provided in the prims parameter. If multiple paths are being\n    returned, they will be separated in the single returned tuple by a value\n    of None. The paths are generated using the same algorithm used when\n    performing loop selections in the viewport."]}, {"indent": 4, "type": "para", "text": ["prims:\n    A list of ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}, " objects that define the path or paths of\n    connected primitives this function should return. Must contain at least\n    two primitives."]}, {"indent": 4, "type": "para", "text": ["loop_type:\n    Controls the type of path returned. Can be any of the\n    ", {"text": "", "value": "/hom/hou/componentLoopType", "fallback_text": "hou.componentLoopType", "fullpath": "/hom/hou/componentLoopType", "scheme": "Hom", "type": "link"}, " values. If using either the\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Extended", "fallback_text": "hou.componentLoopType.Extended", "fullpath": "/hom/hou/componentLoopType/Extended", "scheme": "Hom", "type": "link"}, " or\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Closed", "fallback_text": "hou.componentLoopType.Closed", "fullpath": "/hom/hou/componentLoopType/Closed", "scheme": "Hom", "type": "link"}, " loop types, the inputs prims\n    cannot contain any None entries. Furthermore, each pair of primitives\n    is used to define a separate full loop, so the number of primitives\n    must be even. If these conditions are not met, a\n    ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " exception will be thrown."]}, {"indent": 4, "type": "para", "text": ["Raises a ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if it was unable to construct a loop\n    from the desired components."]}], "indent": 0, "text": [{"text": ["primLoop(self, prims, loop_type)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Prim", "fallback_text": "hou.Prim", "fullpath": "/hom/hou/Prim", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::primLoop"}, "type": "methods_item", "id": "primLoop"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " objects that make a path connecting the\n    points provided in the points parameter. If multiple paths are being\n    returned, they will be separated in the single returned tuple by a value\n    of None. The paths are generated using the same algorithm used when\n    performing loop selections in the viewport."]}, {"indent": 4, "type": "para", "text": ["points:\n    A list of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}, " objects that define the path or paths of\n    connected points this function should return. Must contain at least\n    two points."]}, {"indent": 4, "type": "para", "text": ["loop_type:\n    Controls the type of path returned. Can be any of the\n    ", {"text": "", "value": "/hom/hou/componentLoopType", "fallback_text": "hou.componentLoopType", "fullpath": "/hom/hou/componentLoopType", "scheme": "Hom", "type": "link"}, " values. If using either the\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Extended", "fallback_text": "hou.componentLoopType.Extended", "fullpath": "/hom/hou/componentLoopType/Extended", "scheme": "Hom", "type": "link"}, " or\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Closed", "fallback_text": "hou.componentLoopType.Closed", "fullpath": "/hom/hou/componentLoopType/Closed", "scheme": "Hom", "type": "link"}, " loop types, the inputs points\n    cannot contain any None entries. Furthermore, each pair of points\n    is used to define a separate full loop, so the number of points\n    must be even. If these conditions are not met, a\n    ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " exception will be thrown."]}, {"indent": 4, "type": "para", "text": ["Raises a ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if it was unable to construct a loop\n    from the desired components."]}], "indent": 0, "text": [{"text": ["pointLoop(self, points, full_loop)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::pointLoop"}, "type": "methods_item", "id": "pointLoop"}, {"body": [{"indent": 4, "type": "para", "text": ["Returns a tuple of ", {"text": "", "value": "/hom/hou/Edge", "fallback_text": "hou.Edge", "fullpath": "/hom/hou/Edge", "scheme": "Hom", "type": "link"}, " objects that make a path connecting the\n    edges provided in the edges parameter. If multiple paths are being\n    returned, they will be separated in the single returned tuple by a value\n    of None. The paths are generated using the same algorithm used when\n    performing loop selections in the viewport."]}, {"indent": 4, "type": "para", "text": ["edges:\n    A list of ", {"text": "", "value": "/hom/hou/Edge", "fallback_text": "hou.Edge", "fullpath": "/hom/hou/Edge", "scheme": "Hom", "type": "link"}, " objects that define the path or paths of\n    connected edges this function should return. Must contain at least\n    one or two edges depending on the loop options."]}, {"indent": 4, "type": "para", "text": ["loop_type:\n    Controls the type of path returned. Can be any of the\n    ", {"text": "", "value": "/hom/hou/componentLoopType", "fallback_text": "hou.componentLoopType", "fullpath": "/hom/hou/componentLoopType", "scheme": "Hom", "type": "link"}, " values. If using either the\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Extended", "fallback_text": "hou.componentLoopType.Extended", "fullpath": "/hom/hou/componentLoopType/Extended", "scheme": "Hom", "type": "link"}, " or\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Closed", "fallback_text": "hou.componentLoopType.Closed", "fullpath": "/hom/hou/componentLoopType/Closed", "scheme": "Hom", "type": "link"}, " loop types, the inputs edges\n    cannot contain any None entries. If these conditions are not met, a\n    ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " exception will be thrown."]}, {"indent": 4, "type": "para", "text": ["full_loop_per_edge:\n    If set to True, with the loop_type set to\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Extended", "fallback_text": "hou.componentLoopType.Extended", "fullpath": "/hom/hou/componentLoopType/Extended", "scheme": "Hom", "type": "link"}, " or\n    ", {"text": "", "value": "/hom/hou/componentLoopType/Closed", "fallback_text": "hou.componentLoopType.Closed", "fullpath": "/hom/hou/componentLoopType/Closed", "scheme": "Hom", "type": "link"}, " loop types, each inputs edge\n    is used to create its own full loop or ring. If False, the edges\n    are taken in pairs, and so the number of edges must be even."]}, {"indent": 4, "type": "para", "text": ["force_ring:\n    If set to True, this function will return edge rings instead of edge\n    loops."]}, {"indent": 4, "type": "para", "text": ["allow_ring:\n    If set to True, this function may return an edge ring if the\n    edges provided produce a ring more naturally than they produce a\n    loop (for example if two perpendicular edges are provided from the\n    same row on a polygonal grid). If set to False, only edge loops will\n    be returned."]}, {"indent": 4, "type": "para", "text": ["Raises a ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, " if it was unable to construct a loop\n    from the desired components."]}], "indent": 0, "text": [{"text": ["edgeLoop(self, edges, loop_type, full_loop_per_edge, force_ring, allow_ring)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Edge", "fallback_text": "hou.Edge", "fullpath": "/hom/hou/Edge", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::edgeLoop"}, "type": "methods_item", "id": "edgeLoop"}, {"body": [], "indent": 0, "text": [{"text": ["seamPoints(self, seam_half)"], "type": "code"}, "  \u2192 ", {"text": ["tuple"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Point", "fallback_text": "hou.Point", "fullpath": "/hom/hou/Point", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"status": "ni", "cppname": "HOM_Geometry::seamPoints", "replaces": "/expressions/seampoints"}, "type": "methods_item", "id": "seamPoints"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Loops"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Returns the current cook component selection associated with this geometry.\n    This is the default selection set by the SOP that created the geometry."]}], "indent": 0, "text": [{"text": ["selection(self)"], "type": "code"}, "  \u2192 ", {"text": "", "value": "/hom/hou/Selection", "fallback_text": "hou.Selection", "fullpath": "/hom/hou/Selection", "scheme": "Hom", "type": "link"}], "role": "item", "attrs": {"cppname": "HOM_Geometry::selection"}, "type": "methods_item", "id": "selection"}], "container": true, "role": "item_group", "type": "methods_item_group"}], "indent": 0, "level": 2, "text": ["Selection"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Methods", "role": "section", "container": true, "type": "methods_section", "id": "methods"}], "summary": ["A Geometry object contains the points and primitives that define a 3D\ngeometric shape.  For example, each SOP node in Houdini generates a single\nGeometry object."], "type": "root", "attrs": {"cppname": "HOM_Geometry", "type": "homclass", "group": "geo"}, "title": [{"text": "hou.", "type": "supertitle"}, "Geometry"]}